<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Empirical Precision</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- General Body & Font Styles --- */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #d1d5db; /* text-gray-300 */
            margin: 0;
            padding: 0;
        }

        /* --- Layout Containers --- */
        .container {
            max-width: 1280px;
            margin: 0 auto;
            padding: 1rem;
        }

        .grid-layout { display: grid; grid-template-columns: 1fr; gap: 1.5rem; }
        .db-grid { display: grid; grid-template-columns: 1fr; gap: 1.5rem; }
        .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }

        @media (min-width: 768px) {
            .db-grid { grid-template-columns: repeat(2, 1fr); }
        }

        @media (min-width: 1024px) {
            .grid-layout { grid-template-columns: repeat(3, 1fr); }
            .grid-layout .main-content { grid-column: span 2 / span 2; }
        }

        /* --- Typography --- */
        h1 { font-size: 1.875rem; font-weight: 700; text-align: center; margin-bottom: 1.5rem; color: #f9fafb; }
        h3 { font-size: 1.25rem; font-weight: 600; margin-bottom: 0.75rem; color: #f9fafb; }
        h4 { font-size: 1.125rem; font-weight: 600; margin-bottom: 0.25rem; color: #f9fafb; }
        label { display: block; font-size: 0.875rem; font-weight: 500; color: #9ca3af; margin-bottom: 0.25rem; }
        .checkbox-group label { display: inline-block; margin-right: 1rem; color: #d1d5db; }
        .about-us-p { line-height: 1.6; margin-bottom: 1rem; }

        /* --- Tabs --- */
        .tabs-nav-container { margin-bottom: 1rem; border-bottom: 1px solid #374151; }
        .tabs-nav { display: flex; flex-wrap: wrap; margin-bottom: -1px; }
        .tab-link { padding: 0.75rem 1rem; margin-right: 0.5rem; border-bottom: 2px solid transparent; text-decoration: none; color: #9ca3af; cursor: pointer; font-weight: 500; transition: color 0.2s, border-color 0.2s; }
        .tab-link:hover { color: #e5e7eb; }
        .tab-link.active { border-color: #3b82f6; color: #60a5fa; font-weight: 600; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .sub-tab-link { padding: 0.5rem 1rem; border-radius: 0.375rem; cursor: pointer; color: #9ca3af; }
        .sub-tab-link.active { background-color: #374151; color: #e5e7eb; }

        /* --- Cards & Panels --- */
        .card { background-color: #1f2937; padding: 1rem; border-radius: 0.5rem; border: 1px solid #374151; }
        .control-panel > div:not(:first-child) { border-top: 1px solid #374151; padding-top: 0.75rem; margin-top: 0.75rem; }
        .db-actions .action-group { display: flex; flex-direction: column; gap: 0.75rem; }

        /* --- Buttons --- */
        button, .button { width: 100%; color: #ffffff; padding: 0.6rem 1rem; border-radius: 0.375rem; border: none; cursor: pointer; font-weight: 600; transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; text-align: center; box-sizing: border-box; display: inline-block; text-decoration: none; }
        button:focus, .button:focus { outline: none; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.4); }
        .btn-red { background-color: #ef4444; } .btn-red:hover { background-color: #dc2626; }
        .btn-gray { background-color: #4b5563; color: #f3f4f6; } .btn-gray:hover { background-color: #6b7280; }
        .btn-blue { background-color: #3b82f6; } .btn-blue:hover { background-color: #2563eb; }
        .btn-yellow { background-color: #eab308; } .btn-yellow:hover { background-color: #ca8a04; }
        .btn-orange { background-color: #f97316; } .btn-orange:hover { background-color: #ea580c; }
        .btn-indigo { background-color: #6366f1; } .btn-indigo:hover { background-color: #4f46e5; }
        .btn-small { padding: 0.25rem 0.5rem; font-size: 0.875rem; width: auto; }
        
        .toggle-btn.active { box-shadow: inset 0 2px 4px rgba(0,0,0,0.4); }
        .btn-blue.toggle-btn.active { background-color: #1d4ed8; }
        .btn-yellow.toggle-btn.active { background-color: #a16207; }
        .btn-orange.toggle-btn.active { background-color: #c2410c; }

        .flex-container { display: flex; gap: 0.5rem; }
        .flex-container button { flex: 1 1 0%; }
        
        /* --- Forms --- */
        input[type="file"], input[type="number"], input[type="text"], select { 
            display: block; 
            width: 100%; 
            padding: 0.5rem 0.75rem; 
            border: 1px solid #4b5563; 
            border-radius: 0.375rem; 
            box-sizing: border-box;
            background-color: #374151;
            color: #f3f4f6;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px #1e40af;
        }
        input[type="file"]::file-selector-button {
            background-color: #4b5563;
            color: #f3f4f6;
            border: none;
            padding: 0.4rem 0.75rem;
            border-radius: 0.25rem;
            margin-left: -0.75rem;
            margin-right: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #6b7280;
        }
        .scale-input-container { display: flex; gap: 0.5rem; align-items: center; }
        .scale-input-container input { width: 33.33%; }
        .scale-input-container select { width: 66.67%; }

        /* --- Tables --- */
        .data-table-container { overflow-x: auto; margin-top: 1.5rem; max-height: 400px; border: 1px solid #374151; border-radius: 0.5rem; }
        .data-table { width: 100%; border-collapse: collapse; }
        .data-table th, .data-table td { padding: 0.75rem; text-align: left; border-bottom: 1px solid #374151; word-break: break-all; }
        .data-table th { background-color: #374151; font-weight: 600; position: sticky; top: 0; color: #f9fafb; z-index: 10;}
        .data-table tr:hover { background-color: #2a374a; }
        .data-table tr:last-child td { border-bottom: none; }
        .data-table td .flex-container { justify-content: flex-end; }


        /* --- Canvas & Impact Marking --- */
        .canvas-container {
            overflow: auto;
            border: 1px solid #4b5563;
            border-radius: 0.375rem;
            background-color: #374151;
            max-height: 75vh;
        }
        canvas { 
            cursor: crosshair;
            max-width: none;
            display: block;
        }
        canvas.delete-mode { cursor: not-allowed; }
        .stats-container { margin-top: 1.5rem; }
        .stats-output { font-size: 0.875rem; color: #9ca3af; }
        .stats-output > p { margin: 0.5rem 0; }
        .stats-grid { display: grid; grid-template-columns: 1fr; gap: 1.5rem; margin-top: 0.5rem; }
        .stats-grid p { display: flex; justify-content: space-between; margin: 0.25rem 0; }
        .stats-grid p span:first-child { font-weight: 600; color: #e5e7eb; }
        
        .impact-data-list {
            list-style: none;
            padding: 0;
            margin-top: 1rem;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #374151;
            border-radius: 0.375rem;
        }
        .impact-data-list li {
            padding: 0.5rem 0.75rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #374151;
            gap: 0.5rem;
        }
        .impact-data-list li:last-child {
            border-bottom: none;
        }
        .impact-data-list .velocity-input-tm {
            width: 80px;
            padding: 0.25rem 0.5rem;
            text-align: right;
        }
        #calculationDetails {
             font-size: 0.875rem; 
             color: #9ca3af;
        }
        #calculationDetails h4 {
            margin-top: 0.5rem;
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>Empirical Precision</h1>

        <div class="tabs-nav-container">
            <nav class="tabs-nav" aria-label="Tabs">
                <a class="tab-link active" data-tab="about-us">About Us</a>
                <a class="tab-link" data-tab="firearms">Firearms</a>
                <a class="tab-link" data-tab="loads">Load Data</a>
                <a class="tab-link" data-tab="targets">Targets</a>
                <a class="tab-link" data-tab="marking">Marking</a>
                <a class="tab-link" data-tab="analysis">Analysis</a>
                <a class="tab-link" data-tab="components">Components</a>
                <a class="tab-link" data-tab="misc">Misc</a>
                <a class="tab-link" data-tab="db-management">DB Management</a>
            </nav>
        </div>

        <div id="about-us" class="tab-content active">
            <div class="card">
                <h3>Welcome to Empirical Precision</h3>
                <p class="about-us-p">
                    This web application is a comprehensive tool designed for shooting enthusiasts, competitive marksmen, and handloaders. Our goal is to provide a single, powerful platform to manage every aspect of your shooting hobby, from the components on your reloading bench to the final analysis of your performance on the range.
                </p>
                <h4>Key Features:</h4>
                <ul class="about-us-p" style="list-style-position: inside;">
                    <li><strong>Component Management:</strong> Keep a detailed inventory of your reloading components, including bullets, powders, primers, and brass.</li>
                    <li><strong>Load Data Management:</strong> Develop, save, and manage your specific handload recipes and commercial ammunition.</li>
                    <li><strong>Target Management:</strong> Upload images of your targets to create a digital library for analysis.</li>
                    <li><strong>Impact Marking & Analysis:</strong> Digitize your targets by marking points of aim and impact, then instantly calculate critical statistics like Mean Radius and Standard Deviation.</li>
                    <li><strong>Advanced Diagnostics:</strong> Automatically analyze shot dispersion to identify issues like vertical stringing and correlate it with muzzle velocity data to pinpoint the root cause.</li>
                </ul>
                 <h4>Recommended Workflow:</h4>
                 <p class="about-us-p">
                    For the best experience, we recommend following this workflow:
                 </p>
                 <ol class="about-us-p" style="list-style-position: inside;">
                    <li><strong>Firearms Tab:</strong> Start by adding the firearms you'll be using.</li>
                    <li><strong>Load Data Tab:</strong> Create your load recipes, linking them to your components.</li>
                    <li><strong>Targets Tab:</strong> Upload images of the paper targets you've shot.</li>
                    <li><strong>Marking Tab:</strong> Select a firearm, load, and target. Then, mark your point-of-aim and impacts on the canvas to save a new session. Enter velocity data for each shot if you have it.</li>
                    <li><strong>Analysis Tab:</strong> Load your saved sessions to view detailed statistics, compare performance against other sessions, and use the diagnostic tools to understand your results.</li>
                 </ol>
                 <h4>A Note on Group Size & Statistical Significance</h4>
                 <p class="about-us-p">
                     When evaluating the precision of a load, it's tempting to rely on small, 3 or 5-shot groups. They are quick to shoot and easy to measure. However, the results from such small sample sizes can often be misleading. A tight 3-shot group might be a statistical fluke rather than a true representation of your load's potential, just as a surprisingly wide group might be the result of a single random flyer.
                 </p>
                 <p class="about-us-p">
                     The power of statistical analysis, and a core principle of this application, lies in using larger data sets. As you increase the number of shots in your sample—from 5 to 10, and ideally to 20 or 30—the calculated metrics like <strong>Mean Radius</strong> become far more reliable. These larger groups smooth out the randomness of individual shots, giving you a much clearer picture of the load's true capabilities.
                 </p>
                 <p class="about-us-p">
                     This becomes critically important when comparing two different loads. Is your new handload <em>really</em> more precise than the old one? Comparing two 5-shot groups might not provide a definitive answer, as the difference you see could easily be due to chance. The more data you collect, the more confident you can be in your conclusions.
                 </p>
                 <p class="about-us-p">
                    All your data is stored securely and privately in your local browser database. Nothing is uploaded to a server, ensuring you have full control over your information and can even use the application offline.
                </p>
            </div>
        </div>

        <div id="firearms" class="tab-content">
             <div class="card">
                <h3>Manage Firearms</h3>
                <form id="firearmForm" class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                    <input type="hidden" id="firearmId">
                    <div><label for="firearmNickname">Nickname</label><input type="text" id="firearmNickname" required></div>
                    <div><label for="firearmDiameter">Diameter</label><select id="firearmDiameter"></select></div>
                    <div><label for="firearmCartridge">Cartridge</label><select id="firearmCartridge"></select></div>
                    <div><label for="firearmBarrelLength">Barrel Length</label><input type="number" step="0.1" id="firearmBarrelLength"></div>
                    <div><label for="firearmTwistRate">Twist Rate</label><input type="text" id="firearmTwistRate"></div>
                    <div><label for="firearmMagCoal">Max Mag COAL</label><input type="number" step="0.001" id="firearmMagCoal"></div>
                </form>
                <div class="flex-container" style="margin-top: 1rem; max-width: 400px;">
                    <button type="submit" form="firearmForm" class="btn-blue">Save Firearm</button>
                    <button type="reset" form="firearmForm" class="btn-gray">Clear Form</button>
                </div>
                <div class="data-table-container">
                    <table class="data-table">
                        <thead><tr><th>Nickname</th><th>Cartridge</th><th>Barrel</th><th>Twist</th><th>Actions</th></tr></thead>
                        <tbody id="firearmsTableBody"></tbody>
                    </table>
                </div>
             </div>
        </div>

        <div id="loads" class="tab-content">
            <div class="card">
                <h3>Manage Load Data</h3>
                <div class="tabs-nav" style="border-bottom: 1px solid #374151; margin-bottom: 1.5rem;">
                    <a class="sub-tab-link active" data-subtab="hand-load">Hand Load</a>
                    <a class="sub-tab-link" data-subtab="commercial-ammo">Commercial Ammo</a>
                </div>

                <div id="load-forms-container">
                    <div class="tab-content active" id="hand-load-subtab">
                        <form id="loadForm">
                            <input type="hidden" id="loadId">
                            <div class="form-grid" style="grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                <div><label for="loadDiameter">Diameter</label><select id="loadDiameter"></select></div>
                                <div><label for="loadCartridge">Cartridge</label><select id="loadCartridge"></select></div>
                            </div>
                            <div class="form-grid" style="grid-template-columns: 1fr 2fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                <div><label for="loadBulletWeight">Bullet Weight</label><select id="loadBulletWeight"></select></div>
                                <div><label for="loadBullet">Bullet (Manuf./Name)</label><select id="loadBullet"></select></div>
                                <div><label for="loadBulletLot">Bullet Lot</label><input type="text" id="loadBulletLot"></div>
                            </div>
                            <div class="form-grid" style="grid-template-columns: 1fr 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                <div><label for="loadPowderManufacturer">Powder Manufacturer</label><select id="loadPowderManufacturer"></select></div>
                                <div><label for="loadPowder">Powder</label><select id="loadPowder"></select></div>
                                <div><label for="loadChargeWeight">Charge (grains)</label><input type="number" step="0.1" id="loadChargeWeight" required></div>
                                <div><label for="loadPowderLot">Powder Lot</label><input type="text" id="loadPowderLot"></div>
                            </div>
                            <div class="form-grid" style="grid-template-columns: 1fr 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                <div><label for="loadPrimer">Primer</label><select id="loadPrimer"></select></div>
                                <div><label for="loadPrimerLot">Primer Lot</label><input type="text" id="loadPrimerLot"></div>
                                <div><label for="loadCol">COL</label><input type="number" step="0.001" id="loadCol"></div>
                                <div><label for="loadCbto">CBTO</label><input type="number" step="0.001" id="loadCbto"></div>
                            </div>
                            <div class="form-grid" style="grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                                <div><label for="loadBrass">Brass Manufacturer</label><select id="loadBrass"></select></div>
                                <div><label for="loadBrassLot">Brass Lot</label><input type="text" id="loadBrassLot"></div>
                                <div><label for="loadFirings"># of Firings</label><input type="number" step="1" id="loadFirings"></div>
                            </div>
                        </form>
                        <div class="flex-container" style="margin-top: 1rem; max-width: 400px;">
                            <button type="submit" form="loadForm" class="btn-blue">Save Hand Load</button>
                            <button type="reset" form="loadForm" class="btn-gray">Clear Form</button>
                        </div>
                    </div>

                    <div class="tab-content" id="commercial-ammo-subtab">
                        <form id="commercialAmmoForm" class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                            <input type="hidden" id="commercialAmmoId">
                            <div><label for="commercialAmmoManufacturer">Manufacturer</label><select id="commercialAmmoManufacturer"></select></div>
                            <div><label for="commercialAmmoName">Ammo Name</label><input type="text" id="commercialAmmoName" required></div>
                            <div><label for="commercialAmmoDiameter">Diameter</label><select id="commercialAmmoDiameter"></select></div>
                            <div><label for="commercialAmmoCartridge">Cartridge</label><select id="commercialAmmoCartridge"></select></div>
                            <div><label for="commercialAmmoBulletWeight">Bullet Weight (grains)</label><input type="number" step="0.1" id="commercialAmmoBulletWeight"></div>
                            <div><label for="commercialAmmoLot">Lot #</label><input type="text" id="commercialAmmoLot"></div>
                        </form>
                        <div class="flex-container" style="margin-top: 1rem; max-width: 400px;">
                            <button type="submit" form="commercialAmmoForm" class="btn-blue">Save Commercial Ammo</button>
                            <button type="reset" form="commercialAmmoForm" class="btn-gray">Clear Form</button>
                        </div>
                    </div>
                </div>

                <div class="data-table-container">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Cartridge</th>
                                <th>Details</th>
                                <th>Charge</th>
                                <th>COL / CBTO</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="loadsTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div id="targets" class="tab-content">
            <div class="card">
                <h3>Manage Targets</h3>
                <div>
                    <label for="uploadTargetImage">Upload New Target Image(s)</label>
                    <input type="file" id="uploadTargetImage" accept="image/*" multiple>
                </div>
                <div id="targetGallery" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 1rem; margin-top: 1.5rem;">
                    </div>
            </div>
        </div>

        <div id="marking" class="tab-content">
            <div class="grid-layout">
                <div class="card">
                    <div class="control-panel">
                        <div>
                            <h4>Setup</h4>
                            <label for="savedImageSelect">Load Saved Image</label>
                            <select id="savedImageSelect"></select>

                            <div style="border-top: 1px solid #374151; padding-top: 0.75rem; margin-top: 0.75rem;">
                                <label for="markingSessionSelect">Load Saved Session</label>
                                <select id="markingSessionSelect"></select>
                                <div class="flex-container" style="margin-top: 0.5rem;">
                                    <button id="loadMarkingSessionBtn" class="btn-blue">Load Session</button>
                                    <button id="deleteMarkingSessionBtn" class="btn-red">Delete Session</button>
                                </div>
                            </div>
                            
                            <button id="removeImage" class="btn-red" style="margin-top: 1rem;">Clear Canvas & New Session</button>
                        </div>
                        <div>
                            <h4>Image Controls</h4>
                            <label>Zoom</label>
                            <div class="flex-container">
                                <button id="zoomIn" class="btn-gray">+</button>
                                <button id="zoomOut" class="btn-gray">-</button>
                            </div>
                            <label style="margin-top: 0.5rem;">Scale</label>
                            <div class="scale-input-container">
                                <input type="number" id="scaleDistance" value="1" placeholder="e.g., 1">
                                <select id="scaleUnits">
                                    <option value="in">Inches (in)</option>
                                    <option value="mm">Millimeters (mm)</option>
                                </select>
                            </div>
                            <button id="setScale" class="btn-blue toggle-btn" style="margin-top: 0.5rem;">Set Scale</button>
                        </div>
                        <div>
                            <h4>Marking Tools</h4>
                             <div>
                                <label for="groupSelect">Active Group</label>
                                <select id="groupSelect"></select>
                            </div>
                            <div class="flex-container" style="margin-top: 0.5rem;">
                                <button id="addGroup" class="btn-blue">New Group</button>
                                <button id="deleteGroup" class="btn-red">Delete Group</button>
                            </div>
                            <div class="flex-container" style="margin-top: 0.5rem;">
                                <button id="setPoa" class="btn-blue toggle-btn">Set POA</button>
                                <button id="setPoi" class="btn-blue toggle-btn">Mark Impacts</button>
                            </div>
                            <div class="flex-container" style="margin-top: 0.5rem;">
                                <button id="deleteShot" class="btn-yellow toggle-btn">Delete Shot</button>
                                <button id="deleteLast" class="btn-yellow">Delete Last</button>
                            </div>
                        </div>
                         <div>
                            <h4>Session Info</h4>
                            <label for="firearmSelect">Select Firearm</label>
                            <select id="firearmSelect"></select>
                            <label for="loadSelect" style="margin-top: 0.5rem;">Associate Load (Optional)</label>
                            <select id="loadSelect"></select>
                            <label for="tmTargetDistance" style="margin-top: 0.5rem;">Target Distance</label>
                            <div class="flex-container">
                                <input type="number" id="tmTargetDistance" placeholder="e.g., 100" style="width: 70%;">
                                <select id="tmDistanceUnits" style="width: 30%;">
                                    <option value="yards">Yards</option>
                                    <option value="meters">Meters</option>
                                </select>
                            </div>
                        </div>
                        
                        <div>
                            <h4>Actions</h4>
                            <button id="saveImpactDataBtn" class="btn-blue" style="margin-top: 0.5rem;">Save / Update Session</button>
                        </div>

                    </div>
                </div>
                <div class="main-content card">
                    <div class="canvas-container">
                        <canvas id="targetCanvas" width="800" height="1150"></canvas>
                    </div>
                </div>
            </div>
            <div id="stats-container" class="card stats-container">
                <h3>Impact Data</h3>
                <div id="stats-output" class="stats-output">
                    <p>Impact data will appear here once you mark points and set a scale.</p>
                </div>
            </div>
        </div>

        <div id="analysis" class="tab-content">
            <div class="card">
                <h3>Session Analysis</h3>
                 <div>
                    <label for="firearmFilterSelect">Filter by Firearm</label>
                    <select id="firearmFilterSelect"></select>
                 </div>
                 <div style="margin-top: 1rem;">
                    <label for="sessionSelect">Select Session(s) to Analyze (Ctrl+Click or Cmd+Click for multiple)</label>
                    <select id="sessionSelect" multiple size="8"></select>
                </div>
                <div style="margin-top: 1rem;" class="flex-container">
                    <button id="compareSessionsBtn" class="btn-blue">Analyze Selected Session(s)</button>
                    <button id="exportAnalysisBtn" class="btn-indigo">Export as Image</button>
                </div>
            </div>
            <div class="card" style="margin-top: 1.5rem;">
                <h3>Analysis Results</h3>
                <div id="statAnalysisOutput" class="data-table-container" style="max-height: none;">
                     <p style="text-align: center; padding: 1rem; color: #9ca3af;">Select one or more sessions and click analyze.</p>
                </div>
                <div id="analysisPlotContainer" style="margin-top: 1.5rem; text-align: center;"></div>
            </div>
            <div class="card" style="margin-top: 1.5rem;">
                <h3>Calculation Details & Terminology</h3>
                        <h4>Group Statistics</h4>
                        <p><strong>Mean Radius:</strong> The average distance of all shots from the geometric center (mean point of impact) of the group. A smaller value indicates better precision. This is the primary metric used for ranking.</p>
                        <p><strong>CI for Mean Radius (95%):</strong> This provides a likely range for the true Mean Radius of your load, calculated using bootstrapping. Because you are using a sample of shots, the measured Mean Radius has some uncertainty. The color-coded text indicates the level of confidence based on the width of this interval relative to the measured value. A <strong>narrow interval (High confidence)</strong> gives you high confidence that your measurement is close to the true value. A <strong>wide interval (Low confidence)</strong> indicates high uncertainty, usually due to a small number of shots.</p>

                        <h4>Dispersion Statistics</h4>
                        <p><strong>SD (Horizontal/Vertical):</strong> The Standard Deviation of shot placement on each axis. Measures the consistency of shots along that axis.</p>

                        <h4>Velocity & Dispersion Analysis</h4>
                        <p><strong>Velocity SD (Standard Deviation):</strong> A measure of the consistency of the muzzle velocity. A lower SD indicates more consistent ammunition.</p>
                        <p><strong>Vertical Stringing:</strong> The analysis automatically checks if the vertical spread (SD) of the group is significantly larger than the horizontal spread (specifically, if Vertical SD is > 1.5x Horizontal SD). If detected, it suggests a potential issue, often related to inconsistent muzzle velocity.</p>
                        <p><strong>Velocity Correlation (R²):</strong> If vertical stringing is detected and velocity data is available (for 3+ shots), an R-squared (R²) value is calculated. This value, from 0% to 100%, indicates how much of the vertical shot placement can be explained by changes in velocity. A high R² value (e.g., > 40%) strongly suggests that inconsistent muzzle velocity is a primary cause of the vertical spread.</p>
            </div>
        </div>

        <div id="components" class="tab-content">
            <div class="card">
                <div class="tabs-nav" style="border-bottom: none; margin-bottom: 1.5rem;">
                    <a class="sub-tab-link active" data-subtab="bullets">Bullets</a>
                    <a class="sub-tab-link" data-subtab="powders">Powder</a>
                    <a class="sub-tab-link" data-subtab="primers">Primers</a>
                    <a class="sub-tab-link" data-subtab="brass">Brass</a>
                </div>

                <div class="tab-content active" id="bullets-subtab">
                    <h3>Manage Bullets</h3>
                    <form id="bulletForm" class="form-grid">
                        <input type="hidden" id="bulletId">
                        <div><label for="bulletManufacturer">Manufacturer</label><select id="bulletManufacturer"></select></div>
                        <div><label for="bulletDiameter">Diameter</label><select id="bulletDiameter"></select></div>
                        <div><label for="bulletName">Bullet Name</label><input type="text" id="bulletName" required></div>
                        <div><label for="bulletWeight">Weight (grains)</label><input type="number" id="bulletWeight" step="0.1" required></div>
                        <div><label for="bulletLength">Length (in)</label><input type="number" id="bulletLength" step="0.001"></div>
                    </form>
                    <div class="flex-container" style="margin-top: 1rem; max-width: 400px;">
                        <button type="submit" form="bulletForm" class="btn-blue">Save Bullet</button>
                        <button type="reset" form="bulletForm" class="btn-gray">Clear Form</button>
                    </div>
                    <div class="data-table-container">
                        <table class="data-table">
                            <thead><tr><th>Name</th><th>Manufacturer</th><th>Diameter</th><th>Weight</th><th>Length</th><th>Actions</th></tr></thead>
                            <tbody id="bulletsTableBody"></tbody>
                        </table>
                    </div>
                </div>

                <div class="tab-content" id="powders-subtab">
                    <h3>Manage Powders</h3>
                    <form id="powderForm" class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                        <input type="hidden" id="powderId">
                        <div><label for="powderManufacturer">Manufacturer</label><select id="powderManufacturer"></select></div>
                        <div><label for="powderName">Powder Name</label><input type="text" id="powderName" required></div>
                    </form>
                     <div class="flex-container" style="margin-top: 1rem; max-width: 400px;">
                        <button type="submit" form="powderForm" class="btn-blue">Save Powder</button>
                        <button type="reset" form="powderForm" class="btn-gray">Clear Form</button>
                    </div>
                    <div class="data-table-container">
                        <table class="data-table">
                            <thead><tr><th>Name</th><th>Manufacturer</th><th>Actions</th></tr></thead>
                            <tbody id="powdersTableBody"></tbody>
                        </table>
                    </div>
                </div>

                <div class="tab-content" id="primers-subtab">
                    <h3>Manage Primers</h3>
                    <form id="primerForm" class="form-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                        <input type="hidden" id="primerId">
                        <div><label for="primerManufacturer">Manufacturer</label><select id="primerManufacturer"></select></div>
                        <div><label for="primerName">Primer Name</label><input type="text" id="primerName" required></div>
                    </form>
                     <div class="flex-container" style="margin-top: 1rem; max-width: 400px;">
                        <button type="submit" form="primerForm" class="btn-blue">Save Primer</button>
                        <button type="reset" form="primerForm" class="btn-gray">Clear Form</button>
                    </div>
                    <div class="data-table-container">
                        <table class="data-table">
                            <thead><tr><th>Name</th><th>Manufacturer</th><th>Actions</th></tr></thead>
                            <tbody id="primersTableBody"></tbody>
                        </table>
                    </div>
                </div>

                <div class="tab-content" id="brass-subtab">
                    <h3>Manage Brass</h3>
                    <form id="brassForm" class="form-grid">
                        <input type="hidden" id="brassId">
                        <div><label for="brassDiameter">Diameter</label><select id="brassDiameter"></select></div>
                        <div><label for="brassCartridge">Cartridge</label><select id="brassCartridge"></select></div>
                        <div><label for="brassManufacturer">Manufacturer</label><select id="brassManufacturer"></select></div>
                        <div><label for="brassPrimerPocket">Primer Pocket</label><input type="text" id="brassPrimerPocket"></div>
                        <div><label for="brassPrimerHole">Primer Hole</label><input type="text" id="brassPrimerHole"></div>
                    </form>
                     <div class="flex-container" style="margin-top: 1rem; max-width: 400px;">
                        <button type="submit" form="brassForm" class="btn-blue">Save Brass</button>
                        <button type="reset" form="brassForm" class="btn-gray">Clear Form</button>
                    </div>
                    <div class="data-table-container">
                        <table class="data-table">
                            <thead><tr><th>Cartridge</th><th>Manufacturer</th><th>Pocket</th><th>Hole</th><th>Actions</th></tr></thead>
                            <tbody id="brassTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div id="misc" class="tab-content">
             <div class="card">
                <div class="tabs-nav" style="border-bottom: none; margin-bottom: 1.5rem;">
                    <a class="sub-tab-link active" data-subtab="manufacturers">Manufacturers</a>
                    <a class="sub-tab-link" data-subtab="diameters">Diameters</a>
                    <a class="sub-tab-link" data-subtab="cartridges">Cartridges</a>
                </div>

                <div class="tab-content active" id="manufacturers-subtab">
                    <h3>Manage Manufacturers</h3>
                    <form id="manufacturerForm" class="form-grid" style="grid-template-columns: 1fr; gap: 1.5rem;">
                        <input type="hidden" id="manufacturerId">
                        <div><label for="manufacturerName">Manufacturer Name</label><input type="text" id="manufacturerName" required></div>
                        <div>
                            <label>Type of Manufacturer</label>
                            <div class="checkbox-group">
                                <label><input type="checkbox" name="manufacturerType" value="bullet"> Bullet</label>
                                <label><input type="checkbox" name="manufacturerType" value="powder"> Powder</label>
                                <label><input type="checkbox" name="manufacturerType" value="primer"> Primer</label>
                                <label><input type="checkbox" name="manufacturerType" value="brass"> Brass</label>
                            </div>
                        </div>
                    </form>
                    <div class="flex-container" style="margin-top: 1rem; max-width: 400px;">
                        <button type="submit" form="manufacturerForm" class="btn-blue">Save Manufacturer</button>
                        <button type="reset" form="manufacturerForm" class="btn-gray">Clear Form</button>
                    </div>
                    <div class="data-table-container">
                        <table class="data-table">
                            <thead><tr><th>Name</th><th>Types</th><th>Actions</th></tr></thead>
                            <tbody id="manufacturersTableBody"></tbody>
                        </table>
                    </div>
                </div>

                <div class="tab-content" id="diameters-subtab">
                    <h3>Manage Diameters</h3>
                    <form id="diameterForm" class="form-grid">
                        <input type="hidden" id="diameterId">
                        <div><label for="diameterImperial">Imperial (e.g., .308)</label><input type="text" id="diameterImperial" required></div>
                        <div><label for="diameterMetric">Metric (e.g., 7.62mm)</label><input type="text" id="diameterMetric"></div>
                    </form>
                    <div class="flex-container" style="margin-top: 1rem; max-width: 400px;">
                        <button type="submit" form="diameterForm" class="btn-blue">Save Diameter</button>
                        <button type="reset" form="diameterForm" class="btn-gray">Clear Form</button>
                    </div>
                    <div class="data-table-container">
                        <table class="data-table">
                            <thead><tr><th>Imperial</th><th>Metric</th><th>Actions</th></tr></thead>
                            <tbody id="diametersTableBody"></tbody>
                        </table>
                    </div>
                </div>
                
                <div class="tab-content" id="cartridges-subtab">
                    <h3>Manage Cartridges</h3>
                    <form id="cartridgeForm" class="form-grid">
                        <input type="hidden" id="cartridgeId">
                        <div><label for="cartridgeName">Cartridge Name</label><input type="text" id="cartridgeName" required></div>
                        <div><label for="cartridgeDiameter">Diameter</label><select id="cartridgeDiameter"></select></div>
                        <div><label for="cartridgeOAL">Overall Length (OAL)</label><input type="number" step="0.001" id="cartridgeOAL"></div>
                    </form>
                    <div class="flex-container" style="margin-top: 1rem; max-width: 400px;">
                        <button type="submit" form="cartridgeForm" class="btn-blue">Save Cartridge</button>
                        <button type="reset" form="cartridgeForm" class="btn-gray">Clear Form</button>
                    </div>
                    <div class="data-table-container">
                        <table class="data-table">
                            <thead><tr><th>Name</th><th>Diameter</th><th>OAL</th><th>Actions</th></tr></thead>
                            <tbody id="cartridgesTableBody"></tbody>
                        </table>
                    </div>
                </div>
             </div>
        </div>

        <div id="db-management" class="tab-content">
            <div class="db-grid">
                <div class="card db-actions">
                    <h3>Global Database Actions</h3>
                    <div class="action-group">
                        <button id="exportDbBtn" class="btn-blue">Export Entire Database</button>
                        <div>
                            <label for="importDbInput">Import Entire Database (JSON)</label>
                            <input type="file" id="importDbInput" accept=".json">
                        </div>
                        <button id="deleteDbBtn" class="btn-red">Delete Entire Database</button>
                    </div>
                </div>
                <div class="card db-actions">
                    <h3>Table Specific Actions</h3>
                    <div class="action-group">
                        <div>
                            <label for="tableSelect">Select Table to Manage</label>
                            <select id="tableSelect"></select>
                        </div>
                        <button id="exportTableBtn" class="btn-blue">Export Selected Table</button>
                        <div>
                            <label for="importTableInput">Import to Selected Table (JSON)</label>
                            <input type="file" id="importTableInput" accept=".json">
                        </div>
                        <button id="clearTableBtn" class="btn-orange">Clear Selected Table</button>
                    </div>
                </div>
            </div>
            <div class="card" style="margin-top: 1.5rem;">
                <h3>Table Contents: <span id="selectedTableName" style="text-transform: capitalize;"></span></h3>
                <div id="table-display-container" class="data-table-container">
                    <p style="text-align: center; color: #9ca3af;">Select a table to view its contents.</p>
                </div>
            </div>
        </div>

    </div>
    
    <script>
        // --- DATABASE SETUP ---
        const DB_NAME = 'reloadingDB';
        const DB_VERSION = 2;
        let db;

        const objectStores = [
            'manufacturers', 'diameters', 'bullets', 'powders', 'primers', 
            'brass', 'cartridges', 'firearms', 'loads', 'impactData', 'targetImages'
        ];

        function openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = (event) => { console.error("Database error:", event.target.errorCode); reject(event.target.errorCode); };
                request.onupgradeneeded = (event) => {
                    db = event.target.result;
                    objectStores.forEach(storeName => {
                        if (!db.objectStoreNames.contains(storeName)) {
                            db.createObjectStore(storeName, { keyPath: 'id' });
                        }
                    });
                };
                request.onsuccess = (event) => { db = event.target.result; console.log("Database opened successfully"); resolve(db); };
            });
        }

        // --- UTILITY FUNCTIONS ---
        function generateUniqueId() {
            const array = new Uint8Array(16);
            crypto.getRandomValues(array);
            return btoa(String.fromCharCode.apply(null, array)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }

        function triggerDownload(content, fileName) {
            const a = document.createElement('a');
            const blob = new Blob([content], { type: 'application/json' });
            a.href = URL.createObjectURL(blob);
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function convertToWebP(dataUrl, quality = 0.8) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const webpDataUrl = canvas.toDataURL('image/webp', quality);
                    resolve(webpDataUrl);
                };
                img.onerror = (err) => {
                    console.error("Error loading image for conversion:", err);
                    reject("Failed to load image for WebP conversion.");
                };
                img.src = dataUrl;
            });
        }

        async function refreshAllUI() {
            console.log("Refreshing all application UI components...");
            // Misc & Components are linked, start with base data
            await refreshMiscUI();
            await refreshComponentUI();
            
            // Dependent UI
            await refreshFirearmsUI();
            await refreshLoadsUI();
            await renderTargetImages();
            await refreshImpactMarkingUI();
            
            // Analysis Tab dropdowns
            document.getElementById('sessionSelect').dispatchEvent(new Event('refresh'));
            
            // DB Management Tab (if a table is displayed)
            if (document.getElementById('tableSelect').value) {
                await renderSelectedTable();
            }
            console.log("UI Refresh complete.");
        }

        // --- GENERIC CRUD FUNCTIONS ---
        function updateItem(storeName, item) {
             return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                if (!item.id) { item.id = generateUniqueId(); }
                const request = store.put(item);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
        function deleteItem(storeName, id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function getItem(storeName, id) {
            return new Promise((resolve, reject) => {
                if (!id) return resolve(null);
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function getAllItems(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', async () => {
            await openDB();
            
            const mainTabContainer = document.querySelector('.tabs-nav');
            const mainTabContents = document.querySelectorAll('.container > .tab-content'); // <-- CORRECTED SELECTOR
            mainTabContainer.addEventListener('click', (e) => {
                if (e.target && e.target.classList.contains('tab-link')) {
                    e.preventDefault();
                    const tabId = e.target.getAttribute('data-tab');
                    mainTabContainer.querySelectorAll('.tab-link').forEach(l => l.classList.remove('active'));
                    e.target.classList.add('active');
                    mainTabContents.forEach(content => {
                        content.classList.remove('active');
                        if (content.id === tabId) { 
                            content.classList.add('active'); 
                            if(tabId === 'analysis') {
                                document.getElementById('sessionSelect').dispatchEvent(new Event('refresh'));
                            }
                        }
                    });
                }
            });

            initDbManagement();
            initComponentsManagement();
            initMiscManagement();
            initFirearmsManagement();
            initLoadsManagement();
            initImpactMarking();
            initStatisticalAnalysis();
            initTargetsManagement();
        });

        async function createSessionName(session) {
            if (!session) return "Invalid Session";
            
            // Firearm Text
            let firearmText = 'No Firearm';
            if (session.firearmId) {
                const firearm = await getItem('firearms', session.firearmId);
                firearmText = firearm ? firearm.nickname : 'Unknown Firearm';
            }

            // Load Text
            let loadText = 'No Load';
            if (session.loadId) {
                const load = await getItem('loads', session.loadId);
                if (load) {
                    if (load.loadType === 'commercial') {
                        const mfg = await getItem('manufacturers', load.manufacturerId);
                        loadText = `${mfg ? mfg.name : ''} ${load.name}`;
                    } else {
                        const bullet = await getItem('bullets', load.bulletId);
                        const powder = await getItem('powders', load.powderId);
                        let bulletText = '?gr';
                        if (bullet) {
                            const bulletMfg = await getItem('manufacturers', bullet.manufacturerId);
                            bulletText = `${bulletMfg ? bulletMfg.name : ''} ${bullet.weight}gr`;
                        }
                        const powderName = powder ? powder.name : '?';
                        const chargeWeight = load.chargeWeight || '?';
                        loadText = `HL: ${bulletText} / ${powderName} ${chargeWeight}gr`;
                    }
                }
            }
            
            // Target Text
            let targetText = 'No Target';
            if (session.targetImageId) {
                const target = await getItem('targetImages', session.targetImageId);
                // Truncate long target names for display
                targetText = target ? (target.name.length > 25 ? target.name.substring(0, 22) + '...' : target.name) : 'Deleted Target';
            }

            // Shot Count
            const totalShots = session.shots ? session.shots.length : 0;
            const shotText = totalShots > 0 ? `(${totalShots} shots)` : '';

            return `${firearmText} | ${loadText} | ${targetText} ${shotText}`.trim().replace(/  +/g, ' ');
        }

        // --- DATABASE MANAGEMENT LOGIC ---
        function initDbManagement() {
            const tableSelect = document.getElementById('tableSelect');
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = '-- Select Table --';
            tableSelect.appendChild(defaultOption);

            objectStores.forEach(store => {
                const option = document.createElement('option');
                option.value = store;
                option.textContent = store.charAt(0).toUpperCase() + store.slice(1);
                tableSelect.appendChild(option);
            });

            document.getElementById('exportDbBtn').addEventListener('click', exportDatabase);
            document.getElementById('importDbInput').addEventListener('change', importDatabase);
            document.getElementById('deleteDbBtn').addEventListener('click', deleteDatabase);
            
            document.getElementById('exportTableBtn').addEventListener('click', exportTableData);
            document.getElementById('importTableInput').addEventListener('change', importTableData);
            document.getElementById('clearTableBtn').addEventListener('click', clearTableData);

            tableSelect.addEventListener('change', renderSelectedTable);
        }

        async function renderSelectedTable() {
            const tableName = document.getElementById('tableSelect').value;
            const container = document.getElementById('table-display-container');
            const titleSpan = document.getElementById('selectedTableName');
            container.innerHTML = '';
            titleSpan.textContent = tableName;

            if (!tableName) {
                container.innerHTML = '<p style="text-align: center; color: #9ca3af;">Select a table to view its contents.</p>';
                return;
            }

            const items = await getAllItems(tableName);

            if (items.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #9ca3af;">This table is empty.</p>';
                return;
            }

            const table = document.createElement('table');
            table.className = 'data-table';
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            const headerRow = document.createElement('tr');

            const headerSet = new Set();
            items.forEach(item => {
                Object.keys(item).forEach(key => headerSet.add(key));
            });
            const headers = Array.from(headerSet);

            if (headers.includes('id')) {
                headers.splice(headers.indexOf('id'), 1);
                headers.unshift('id');
            }

            headers.forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            items.forEach(item => {
                const row = document.createElement('tr');
                headers.forEach(header => {
                    const td = document.createElement('td');
                    let value = item[header];
                    if (header === 'dataUrl' && typeof value === 'string' && value.length > 100) {
                        value = value.substring(0, 100) + '...';
                    }
                    if (value === undefined || value === null) {
                        td.textContent = '';
                    } else if (typeof value === 'object') {
                        // Don't expand large objects in the table view
                        td.textContent = JSON.stringify(value).length > 200 ? '{...}' : JSON.stringify(value, null, 2);
                    }
                    else {
                        td.textContent = value;
                    }
                    row.appendChild(td);
                });
                tbody.appendChild(row);
            });

            table.appendChild(thead);
            table.appendChild(tbody);
            container.appendChild(table);
        }

        async function exportDatabase() {
            const allData = {};
            for (const storeName of objectStores) { allData[storeName] = await getAllItems(storeName); }
            triggerDownload(JSON.stringify(allData, null, 2), 'reloading-db-backup.json');
        }

        function importDatabase(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    const transaction = db.transaction(objectStores, 'readwrite');
                    for (const storeName of objectStores) {
                        if (data[storeName]) {
                            const store = transaction.objectStore(storeName);
                            store.clear();
                            for (const item of data[storeName]) { store.put(item); }
                        }
                    }
                    transaction.oncomplete = async () => {
                        alert('Database imported successfully!');
                        event.target.value = '';
                        await refreshAllUI();
                    };
                    transaction.onerror = (err) => { console.error('Import transaction error:', err); alert('Failed to import database.'); };
                } catch (error) { console.error('Error parsing or importing DB file:', error); alert('Invalid database file format.'); }
            };
            reader.readAsText(file);
        }

        function deleteDatabase() {
            if (confirm('Are you sure you want to permanently delete the entire database? This action cannot be undone.')) {
                db.close();
                const req = indexedDB.deleteDatabase(DB_NAME);
                req.onsuccess = () => { alert('Database deleted successfully. The page will now reload.'); location.reload(); };
                req.onerror = (err) => { console.error('Error deleting database:', err); alert('Could not delete the database.'); };
                req.onblocked = () => { alert('Could not delete database because it is open elsewhere. Please close all other tabs with this app open and try again.'); };
            }
        }

        async function exportTableData() {
            const tableName = document.getElementById('tableSelect').value;
            if (!tableName) {
                alert('Please select a table to export.');
                return;
            }
            const data = await getAllItems(tableName);
            triggerDownload(JSON.stringify(data, null, 2), `${tableName}-backup.json`);
        }

        function importTableData(event) {
            const file = event.target.files[0];
            if (!file) return;
            const tableName = document.getElementById('tableSelect').value;
             if (!tableName) {
                alert('Please select a table to import data into.');
                event.target.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!Array.isArray(data)) throw new Error('JSON is not an array.');
                    const transaction = db.transaction([tableName], 'readwrite');
                    const store = transaction.objectStore(tableName);
                    store.clear();
                    data.forEach(item => store.put(item));
                    transaction.oncomplete = async () => { 
                        alert(`Table '${tableName}' imported successfully!`); 
                        event.target.value = '';
                        await refreshAllUI();
                    };
                    transaction.onerror = (err) => { console.error(`Import error for table ${tableName}:`, err); alert(`Failed to import data for table '${tableName}'.`); };
                } catch (error) { console.error('Error parsing or importing table file:', error); alert('Invalid table file format. Must be a JSON array.'); }
            };
            reader.readAsText(file);
        }

        function clearTableData() {
            const tableName = document.getElementById('tableSelect').value;
             if (!tableName) {
                alert('Please select a table to clear.');
                return;
            }
            if (confirm(`Are you sure you want to delete all data from the '${tableName}' table?`)) {
                const transaction = db.transaction([tableName], 'readwrite');
                const store = transaction.objectStore(tableName);
                store.clear();
                transaction.oncomplete = async () => { 
                    alert(`Table '${tableName}' has been cleared.`); 
                    await refreshAllUI();
                };
                transaction.onerror = (err) => { console.error(`Error clearing table ${tableName}:`, err); alert(`Failed to clear table '${tableName}'.`); };
            }
        }
        
        // --- MISC MANAGEMENT LOGIC ---
        function initMiscManagement() {
            const subTabContainer = document.querySelector('#misc .tabs-nav');
            const subTabContents = document.querySelectorAll('#misc .tab-content');
            subTabContainer.addEventListener('click', (e) => {
                if(e.target && e.target.classList.contains('sub-tab-link')) {
                    e.preventDefault();
                    const subTabId = e.target.getAttribute('data-subtab');
                    subTabContainer.querySelectorAll('.sub-tab-link').forEach(l => l.classList.remove('active'));
                    e.target.classList.add('active');
                    subTabContents.forEach(content => {
                        content.classList.remove('active');
                        if (content.id === `${subTabId}-subtab`) { content.classList.add('active'); }
                    });
                }
            });

            document.getElementById('manufacturerForm').addEventListener('submit', handleManufacturerSubmit);
            document.getElementById('manufacturerForm').addEventListener('reset', () => document.getElementById('manufacturerId').value = '');
            document.getElementById('manufacturersTableBody').addEventListener('click', handleManufacturerTableClick);

            document.getElementById('diameterForm').addEventListener('submit', handleDiameterSubmit);
            document.getElementById('diameterForm').addEventListener('reset', () => document.getElementById('diameterId').value = '');
            document.getElementById('diametersTableBody').addEventListener('click', handleDiameterTableClick);
            
            document.getElementById('cartridgeForm').addEventListener('submit', handleCartridgeSubmit);
            document.getElementById('cartridgeForm').addEventListener('reset', () => document.getElementById('cartridgeId').value = '');
            document.getElementById('cartridgesTableBody').addEventListener('click', handleCartridgeTableClick);

            renderManufacturersTable();
            renderDiametersTable();
            renderCartridgesTable();
            refreshMiscUI();
        }
        
        async function refreshMiscUI() {
            const diameters = await getAllItems('diameters');
            populateSelect('cartridgeDiameter', diameters, 'imperial', 'id');
        }

        async function handleManufacturerSubmit(e) {
            e.preventDefault();
            const types = Array.from(document.querySelectorAll('input[name="manufacturerType"]:checked')).map(cb => cb.value);
            const manufacturer = {
                id: document.getElementById('manufacturerId').value || generateUniqueId(),
                name: document.getElementById('manufacturerName').value,
                type: types
            };
            await updateItem('manufacturers', manufacturer);
            e.target.reset();
            renderManufacturersTable();
            refreshComponentUI();
        }

        async function renderManufacturersTable() {
            const items = await getAllItems('manufacturers');
            const tableBody = document.getElementById('manufacturersTableBody');
            tableBody.innerHTML = '';
            for (const item of items) {
                const row = `
                    <tr>
                        <td>${item.name}</td>
                        <td>${item.type ? item.type.join(', ') : 'N/A'}</td>
                        <td>
                            <div class="flex-container">
                                <button class="btn-yellow btn-small" data-id="${item.id}" data-action="edit">Edit</button>
                                <button class="btn-red btn-small" data-id="${item.id}" data-action="delete">Delete</button>
                            </div>
                        </td>
                    </tr>`;
                tableBody.insertAdjacentHTML('beforeend', row);
            }
        }

        async function handleManufacturerTableClick(e) {
            const { id, action } = e.target.dataset;
            if (!id || !action) return;
            if (action === 'delete') {
                if (confirm('Are you sure?')) { await deleteItem('manufacturers', id); renderManufacturersTable(); refreshComponentUI(); }
            } else if (action === 'edit') {
                const item = await getItem('manufacturers', id);
                document.getElementById('manufacturerId').value = item.id;
                document.getElementById('manufacturerName').value = item.name;
                document.querySelectorAll('input[name="manufacturerType"]').forEach(cb => {
                    cb.checked = item.type && item.type.includes(cb.value);
                });
            }
        }

        async function handleDiameterSubmit(e) {
            e.preventDefault();
            const diameter = {
                id: document.getElementById('diameterId').value || generateUniqueId(),
                imperial: document.getElementById('diameterImperial').value,
                metric: document.getElementById('diameterMetric').value
            };
            await updateItem('diameters', diameter);
            e.target.reset();
            renderDiametersTable();
            refreshComponentUI();
            refreshMiscUI();
            refreshFirearmsUI();
            refreshLoadsUI();
        }

        async function renderDiametersTable() {
            const items = await getAllItems('diameters');
            const tableBody = document.getElementById('diametersTableBody');
            tableBody.innerHTML = '';
            for (const item of items) {
                const row = `
                    <tr>
                        <td>${item.imperial}</td>
                        <td>${item.metric}</td>
                        <td>
                            <div class="flex-container">
                                <button class="btn-yellow btn-small" data-id="${item.id}" data-action="edit">Edit</button>
                                <button class="btn-red btn-small" data-id="${item.id}" data-action="delete">Delete</button>
                            </div>
                        </td>
                    </tr>`;
                tableBody.insertAdjacentHTML('beforeend', row);
            }
        }

        async function handleDiameterTableClick(e) {
            const { id, action } = e.target.dataset;
            if (!id || !action) return;
            if (action === 'delete') {
                if (confirm('Are you sure?')) { await deleteItem('diameters', id); renderDiametersTable(); refreshComponentUI(); refreshMiscUI(); refreshFirearmsUI(); refreshLoadsUI(); }
            } else if (action === 'edit') {
                const item = await getItem('diameters', id);
                document.getElementById('diameterId').value = item.id;
                document.getElementById('diameterImperial').value = item.imperial;
                document.getElementById('diameterMetric').value = item.metric;
            }
        }
        
        async function handleCartridgeSubmit(e) {
            e.preventDefault();
            const cartridge = {
                id: document.getElementById('cartridgeId').value || generateUniqueId(),
                name: document.getElementById('cartridgeName').value,
                diameterId: document.getElementById('cartridgeDiameter').value,
                oal: parseFloat(document.getElementById('cartridgeOAL').value)
            };
            await updateItem('cartridges', cartridge);
            e.target.reset();
            renderCartridgesTable();
            refreshFirearmsUI();
            refreshLoadsUI();
        }

        async function renderCartridgesTable() {
            const [items, diameters] = await Promise.all([
                getAllItems('cartridges'),
                getAllItems('diameters')
            ]);
            const diameterMap = new Map(diameters.map(d => [d.id, d.imperial]));
            const tableBody = document.getElementById('cartridgesTableBody');
            tableBody.innerHTML = '';
            for (const item of items) {
                const diameterImperial = diameterMap.get(item.diameterId) || 'N/A';
                const row = `
                    <tr>
                        <td>${item.name}</td>
                        <td>${diameterImperial}</td>
                        <td>${item.oal || ''}</td>
                        <td>
                            <div class="flex-container">
                                <button class="btn-yellow btn-small" data-id="${item.id}" data-action="edit">Edit</button>
                                <button class="btn-red btn-small" data-id="${item.id}" data-action="delete">Delete</button>
                            </div>
                        </td>
                    </tr>`;
                tableBody.insertAdjacentHTML('beforeend', row);
            }
        }

        async function handleCartridgeTableClick(e) {
            const { id, action } = e.target.dataset;
            if (!id || !action) return;
            if (action === 'delete') {
                if (confirm('Are you sure?')) { 
                    await deleteItem('cartridges', id); 
                    renderCartridgesTable(); 
                    refreshFirearmsUI(); 
                    refreshLoadsUI();
                }
            } else if (action === 'edit') {
                const item = await getItem('cartridges', id);
                document.getElementById('cartridgeId').value = item.id;
                document.getElementById('cartridgeName').value = item.name;
                document.getElementById('cartridgeDiameter').value = item.diameterId;
                document.getElementById('cartridgeOAL').value = item.oal;
            }
        }

        // --- COMPONENTS MANAGEMENT LOGIC ---
        
        async function refreshBrassFormDropDowns(diameterId = null) {
            const allDiameters = await getAllItems('diameters');
            const allCartridges = await getAllItems('cartridges');
            
            populateSelect('brassDiameter', allDiameters, 'imperial', 'id');
            if(diameterId) {
                document.getElementById('brassDiameter').value = diameterId;
            }

            const selectedDiameter = document.getElementById('brassDiameter').value;
            const filteredCartridges = selectedDiameter ? allCartridges.filter(c => c.diameterId === selectedDiameter) : allCartridges;
            populateSelect('brassCartridge', filteredCartridges, 'name', 'id');
        }

        function initComponentsManagement() {
            const subTabContainer = document.querySelector('#components .tabs-nav');
            const subTabContents = document.querySelectorAll('#components .tab-content');
            subTabContainer.addEventListener('click', (e) => {
                if(e.target && e.target.classList.contains('sub-tab-link')) {
                    e.preventDefault();
                    const subTabId = e.target.getAttribute('data-subtab');
                    subTabContainer.querySelectorAll('.sub-tab-link').forEach(l => l.classList.remove('active'));
                    e.target.classList.add('active');
                    subTabContents.forEach(content => {
                        content.classList.remove('active');
                        if (content.id === `${subTabId}-subtab`) { content.classList.add('active'); }
                    });
                }
            });

            document.getElementById('bulletForm').addEventListener('submit', handleBulletSubmit);
            document.getElementById('bulletForm').addEventListener('reset', () => document.getElementById('bulletId').value = '');
            document.getElementById('bulletsTableBody').addEventListener('click', handleBulletTableClick);
            
            document.getElementById('powderForm').addEventListener('submit', handlePowderSubmit);
            document.getElementById('powderForm').addEventListener('reset', () => document.getElementById('powderId').value = '');
            document.getElementById('powdersTableBody').addEventListener('click', handlePowderTableClick);

            document.getElementById('primerForm').addEventListener('submit', handlePrimerSubmit);
            document.getElementById('primerForm').addEventListener('reset', () => document.getElementById('primerId').value = '');
            document.getElementById('primersTableBody').addEventListener('click', handlePrimerTableClick);

            document.getElementById('brassForm').addEventListener('submit', handleBrassSubmit);
            document.getElementById('brassForm').addEventListener('reset', () => document.getElementById('brassId').value = '');
            document.getElementById('brassTableBody').addEventListener('click', handleBrassTableClick);
            document.getElementById('brassDiameter').addEventListener('change', () => refreshBrassFormDropDowns());

            refreshComponentUI();
        }

        async function refreshComponentUI() {
            const manufacturers = await getAllItems('manufacturers');
            const diameters = await getAllItems('diameters');
            
            populateSelect('bulletManufacturer', manufacturers.filter(m => m.type && m.type.includes('bullet')), 'name', 'id');
            populateSelect('powderManufacturer', manufacturers.filter(m => m.type && m.type.includes('powder')), 'name', 'id');
            populateSelect('primerManufacturer', manufacturers.filter(m => m.type && m.type.includes('primer')), 'name', 'id');
            populateSelect('brassManufacturer', manufacturers.filter(m => m.type && m.type.includes('brass')), 'name', 'id');
            populateSelect('bulletDiameter', diameters, 'imperial', 'id');

            refreshBrassFormDropDowns();
            renderBulletsTable();
            renderPowdersTable();
            renderPrimersTable();
            renderBrassTable();
        }

        function populateSelect(elementId, data, textKey, valueKey) {
            const select = document.getElementById(elementId);
            const currentVal = select.value;
            select.innerHTML = '<option value="">-- Select --</option>';
            data.forEach(item => {
                const option = document.createElement('option');
                option.value = item[valueKey];
                option.textContent = item[textKey];
                select.appendChild(option);
            });
            select.value = currentVal;
        }

        async function handleBulletSubmit(e) {
            e.preventDefault();
            const bullet = {
                id: document.getElementById('bulletId').value || generateUniqueId(),
                manufacturerId: document.getElementById('bulletManufacturer').value,
                diameterId: document.getElementById('bulletDiameter').value,
                name: document.getElementById('bulletName').value,
                weight: parseFloat(document.getElementById('bulletWeight').value),
                length: parseFloat(document.getElementById('bulletLength').value)
            };
            await updateItem('bullets', bullet);
            e.target.reset();
            renderBulletsTable();
            refreshLoadsUI();
        }

        async function renderBulletsTable() {
            const [bullets, manufacturers, diameters] = await Promise.all([
                getAllItems('bullets'),
                getAllItems('manufacturers'),
                getAllItems('diameters')
            ]);

            const manufacturerMap = new Map(manufacturers.map(m => [m.id, m.name]));
            const diameterMap = new Map(diameters.map(d => [d.id, d.imperial]));

            const tableBody = document.getElementById('bulletsTableBody');
            tableBody.innerHTML = '';

            for (const bullet of bullets) {
                const manufacturerName = manufacturerMap.get(bullet.manufacturerId) || 'N/A';
                const diameterImperial = diameterMap.get(bullet.diameterId) || 'N/A';
                
                const row = `
                    <tr>
                        <td>${bullet.name}</td>
                        <td>${manufacturerName}</td>
                        <td>${diameterImperial}</td>
                        <td>${bullet.weight} gr</td>
                        <td>${bullet.length ? bullet.length.toFixed(3) + '"' : ''}</td>
                        <td>
                            <div class="flex-container">
                                <button class="btn-yellow btn-small" data-id="${bullet.id}" data-action="edit">Edit</button>
                                <button class="btn-red btn-small" data-id="${bullet.id}" data-action="delete">Delete</button>
                            </div>
                        </td>
                    </tr>`;
                tableBody.insertAdjacentHTML('beforeend', row);
            }
        }

        async function handleBulletTableClick(e) {
            const { id, action } = e.target.dataset;
            if (!id || !action) return;
            if (action === 'delete') {
                if (confirm('Are you sure?')) { 
                    await deleteItem('bullets', id); 
                    renderBulletsTable(); 
                    refreshLoadsUI();
                }
            } else if (action === 'edit') {
                const bullet = await getItem('bullets', id);
                document.getElementById('bulletId').value = bullet.id;
                document.getElementById('bulletManufacturer').value = bullet.manufacturerId;
                document.getElementById('bulletDiameter').value = bullet.diameterId;
                document.getElementById('bulletName').value = bullet.name;
                document.getElementById('bulletWeight').value = bullet.weight;
                document.getElementById('bulletLength').value = bullet.length;
            }
        }

        async function handlePowderSubmit(e) {
            e.preventDefault();
            const powder = {
                id: document.getElementById('powderId').value || generateUniqueId(),
                manufacturerId: document.getElementById('powderManufacturer').value,
                name: document.getElementById('powderName').value
            };
            await updateItem('powders', powder);
            e.target.reset();
            renderPowdersTable();
            refreshLoadsUI();
        }

        async function renderPowdersTable() {
            const [powders, manufacturers] = await Promise.all([
                getAllItems('powders'),
                getAllItems('manufacturers')
            ]);
            const manufacturerMap = new Map(manufacturers.map(m => [m.id, m.name]));
            const tableBody = document.getElementById('powdersTableBody');
            tableBody.innerHTML = '';
            for (const powder of powders) {
                const manufacturerName = manufacturerMap.get(powder.manufacturerId) || 'N/A';
                const row = `
                    <tr>
                        <td>${powder.name}</td>
                        <td>${manufacturerName}</td>
                        <td>
                            <div class="flex-container">
                                <button class="btn-yellow btn-small" data-id="${powder.id}" data-action="edit">Edit</button>
                                <button class="btn-red btn-small" data-id="${powder.id}" data-action="delete">Delete</button>
                            </div>
                        </td>
                    </tr>`;
                tableBody.insertAdjacentHTML('beforeend', row);
            }
        }

         async function handlePowderTableClick(e) {
            const { id, action } = e.target.dataset;
            if (!id || !action) return;
            if (action === 'delete') {
                if (confirm('Are you sure?')) { 
                    await deleteItem('powders', id); 
                    renderPowdersTable(); 
                    refreshLoadsUI();
                }
            } else if (action === 'edit') {
                const item = await getItem('powders', id);
                document.getElementById('powderId').value = item.id;
                document.getElementById('powderManufacturer').value = item.manufacturerId;
                document.getElementById('powderName').value = item.name;
            }
        }

        async function handlePrimerSubmit(e) {
            e.preventDefault();
            const primer = {
                id: document.getElementById('primerId').value || generateUniqueId(),
                manufacturerId: document.getElementById('primerManufacturer').value,
                name: document.getElementById('primerName').value
            };
            await updateItem('primers', primer);
            e.target.reset();
            renderPrimersTable();
            refreshLoadsUI();
        }

        async function renderPrimersTable() {
            const [primers, manufacturers] = await Promise.all([
                getAllItems('primers'),
                getAllItems('manufacturers')
            ]);
            const manufacturerMap = new Map(manufacturers.map(m => [m.id, m.name]));
            const tableBody = document.getElementById('primersTableBody');
            tableBody.innerHTML = '';
            for (const primer of primers) {
                const manufacturerName = manufacturerMap.get(primer.manufacturerId) || 'N/A';
                const row = `
                    <tr>
                        <td>${primer.name}</td>
                        <td>${manufacturerName}</td>
                        <td>
                            <div class="flex-container">
                                <button class="btn-yellow btn-small" data-id="${primer.id}" data-action="edit">Edit</button>
                                <button class="btn-red btn-small" data-id="${primer.id}" data-action="delete">Delete</button>
                            </div>
                        </td>
                    </tr>`;
                tableBody.insertAdjacentHTML('beforeend', row);
            }
        }

        async function handlePrimerTableClick(e) {
            const { id, action } = e.target.dataset;
            if (!id || !action) return;
            if (action === 'delete') {
                if (confirm('Are you sure?')) { 
                    await deleteItem('primers', id); 
                    renderPrimersTable(); 
                    refreshLoadsUI();
                }
            } else if (action === 'edit') {
                const item = await getItem('primers', id);
                document.getElementById('primerId').value = item.id;
                document.getElementById('primerManufacturer').value = item.manufacturerId;
                document.getElementById('primerName').value = item.name;
            }
        }

        async function handleBrassSubmit(e) {
            e.preventDefault();
            const brass = {
                id: document.getElementById('brassId').value || generateUniqueId(),
                cartridgeId: document.getElementById('brassCartridge').value,
                manufacturerId: document.getElementById('brassManufacturer').value,
                primerPocket: document.getElementById('brassPrimerPocket').value,
                primerHole: document.getElementById('brassPrimerHole').value
            };
            await updateItem('brass', brass);
            e.target.reset();
            renderBrassTable();
            refreshLoadsUI();
        }
        
        async function renderBrassTable() {
            const [brassItems, manufacturers, cartridges] = await Promise.all([
                getAllItems('brass'),
                getAllItems('manufacturers'),
                getAllItems('cartridges')
            ]);
            const manufacturerMap = new Map(manufacturers.map(m => [m.id, m.name]));
            const cartridgeMap = new Map(cartridges.map(c => [c.id, c.name]));

            const tableBody = document.getElementById('brassTableBody');
            tableBody.innerHTML = '';
            for (const brass of brassItems) {
                const manufacturerName = manufacturerMap.get(brass.manufacturerId) || 'N/A';
                const cartridgeName = cartridgeMap.get(brass.cartridgeId) || 'N/A';
                const row = `
                    <tr>
                        <td>${cartridgeName}</td>
                        <td>${manufacturerName}</td>
                        <td>${brass.primerPocket}</td>
                        <td>${brass.primerHole}</td>
                        <td>
                            <div class="flex-container">
                                <button class="btn-yellow btn-small" data-id="${brass.id}" data-action="edit">Edit</button>
                                <button class="btn-red btn-small" data-id="${brass.id}" data-action="delete">Delete</button>
                            </div>
                        </td>
                    </tr>`;
                tableBody.insertAdjacentHTML('beforeend', row);
            }
        }

        async function handleBrassTableClick(e) {
            const { id, action } = e.target.dataset;
            if (!id || !action) return;
            if (action === 'delete') {
                if (confirm('Are you sure?')) { 
                    await deleteItem('brass', id); 
                    renderBrassTable(); 
                    refreshLoadsUI();
                }
            } else if (action === 'edit') {
                const item = await getItem('brass', id);
                const cartridge = await getItem('cartridges', item.cartridgeId);
                if (cartridge) {
                    await refreshBrassFormDropDowns(cartridge.diameterId);
                    document.getElementById('brassCartridge').value = item.cartridgeId;
                }
                document.getElementById('brassId').value = item.id;
                document.getElementById('brassManufacturer').value = item.manufacturerId;
                document.getElementById('brassPrimerPocket').value = item.primerPocket;
                document.getElementById('brassPrimerHole').value = item.primerHole;
            }
        }
        
        async function refreshFirearmCartridgeDropdown() {
            const diameterId = document.getElementById('firearmDiameter').value;
            const allCartridges = await getAllItems('cartridges');
            const filteredCartridges = diameterId
                ? allCartridges.filter(c => c.diameterId === diameterId)
                : []; 
            populateSelect('firearmCartridge', filteredCartridges, 'name', 'id');
        }

        function initFirearmsManagement() {
            document.getElementById('firearmForm').addEventListener('submit', handleFirearmSubmit);
            document.getElementById('firearmForm').addEventListener('reset', () => {
                document.getElementById('firearmId').value = '';
                setTimeout(refreshFirearmsUI, 0);
            });
            document.getElementById('firearmsTableBody').addEventListener('click', handleFirearmTableClick);
            document.getElementById('firearmDiameter').addEventListener('change', refreshFirearmCartridgeDropdown);

            refreshFirearmsUI();
        }

        async function refreshFirearmsUI() {
            const diameters = await getAllItems('diameters');
            populateSelect('firearmDiameter', diameters, 'imperial', 'id');
            await refreshFirearmCartridgeDropdown();
            renderFirearmsTable();
        }

        async function handleFirearmSubmit(e) {
            e.preventDefault();
            const firearm = {
                id: document.getElementById('firearmId').value || generateUniqueId(),
                nickname: document.getElementById('firearmNickname').value,
                diameterId: document.getElementById('firearmDiameter').value,
                cartridgeId: document.getElementById('firearmCartridge').value,
                barrelLength: parseFloat(document.getElementById('firearmBarrelLength').value),
                twistRate: document.getElementById('firearmTwistRate').value,
                magCoal: parseFloat(document.getElementById('firearmMagCoal').value)
            };
            await updateItem('firearms', firearm);
            e.target.reset();
            renderFirearmsTable();
            refreshImpactMarkingUI(); 
        }

        async function renderFirearmsTable() {
            const [firearms, cartridges] = await Promise.all([
                getAllItems('firearms'),
                getAllItems('cartridges')
            ]);
            const cartridgeMap = new Map(cartridges.map(c => [c.id, c.name]));
            const tableBody = document.getElementById('firearmsTableBody');
            tableBody.innerHTML = '';
            for (const firearm of firearms) {
                const cartridgeName = cartridgeMap.get(firearm.cartridgeId) || 'N/A';
                const row = `
                    <tr>
                        <td>${firearm.nickname}</td>
                        <td>${cartridgeName}</td>
                        <td>${firearm.barrelLength || ''}"</td>
                        <td>${firearm.twistRate || ''}</td>
                        <td>
                            <div class="flex-container">
                                <button class="btn-yellow btn-small" data-id="${firearm.id}" data-action="edit">Edit</button>
                                <button class="btn-red btn-small" data-id="${firearm.id}" data-action="delete">Delete</button>
                            </div>
                        </td>
                    </tr>`;
                tableBody.insertAdjacentHTML('beforeend', row);
            }
        }

        async function handleFirearmTableClick(e) {
            const { id, action } = e.target.dataset;
            if (!id || !action) return;
            if (action === 'delete') {
                if (confirm('Are you sure?')) { 
                    await deleteItem('firearms', id); 
                    renderFirearmsTable(); 
                    refreshImpactMarkingUI(); 
                }
            } else if (action === 'edit') {
                const item = await getItem('firearms', id);
                document.getElementById('firearmId').value = item.id;
                document.getElementById('firearmNickname').value = item.nickname;
                document.getElementById('firearmDiameter').value = item.diameterId;
                await refreshFirearmCartridgeDropdown();
                document.getElementById('firearmCartridge').value = item.cartridgeId;
                document.getElementById('firearmBarrelLength').value = item.barrelLength;
                document.getElementById('firearmTwistRate').value = item.twistRate;
                document.getElementById('firearmMagCoal').value = item.magCoal;
            }
        }
        
        // --- LOADS MANAGEMENT LOGIC ---
        async function refreshLoadCartridgeDropdown() {
            const allCartridges = await getAllItems('cartridges');
            const selectedDiameter = document.getElementById('loadDiameter').value;
            const filteredCartridges = selectedDiameter ? allCartridges.filter(c => c.diameterId === selectedDiameter) : [];
            populateSelect('loadCartridge', filteredCartridges, 'name', 'id');
        }

        async function refreshBulletWeightDropdown() {
            const diameterId = document.getElementById('loadDiameter').value;
            const bulletWeightSelect = document.getElementById('loadBulletWeight');
            const bulletSelect = document.getElementById('loadBullet');

            bulletWeightSelect.innerHTML = '<option value="">-- Select --</option>';
            bulletSelect.innerHTML = '<option value="">-- Select --</option>';

            if (!diameterId) return;

            const allBullets = await getAllItems('bullets');
            const filteredBullets = allBullets.filter(b => b.diameterId === diameterId);

            const weights = [...new Set(filteredBullets.map(b => b.weight))];
            weights.sort((a, b) => a - b);

            weights.forEach(weight => {
                const option = document.createElement('option');
                option.value = weight;
                option.textContent = `${weight} gr`;
                bulletWeightSelect.appendChild(option);
            });
        }

        async function refreshBulletNameDropdown() {
            const diameterId = document.getElementById('loadDiameter').value;
            const selectedWeight = document.getElementById('loadBulletWeight').value;
            const bulletSelect = document.getElementById('loadBullet');

            bulletSelect.innerHTML = '<option value="">-- Select --</option>';

            if (!diameterId || !selectedWeight) return;

            const allBullets = await getAllItems('bullets');
            const allManufacturers = await getAllItems('manufacturers');
            const filteredBullets = allBullets.filter(b => b.diameterId === diameterId && b.weight == selectedWeight);

            for (const bullet of filteredBullets) {
                const manufacturer = allManufacturers.find(m => m.id === bullet.manufacturerId);
                const option = document.createElement('option');
                option.value = bullet.id;
                option.textContent = `${manufacturer ? manufacturer.name : ''} ${bullet.name}`;
                bulletSelect.appendChild(option);
            }
        }
        
        async function refreshBrassDropdownForLoad() {
            const selectedCartridgeId = document.getElementById('loadCartridge').value;
            const allBrass = await getAllItems('brass');
            const brassSelect = document.getElementById('loadBrass');
            
            const filteredBrass = selectedCartridgeId ? allBrass.filter(b => b.cartridgeId === selectedCartridgeId) : [];

            const oldValue = brassSelect.value;
            brassSelect.innerHTML = '<option value="">-- Select --</option>';
            for (const brassItem of filteredBrass) {
                const manufacturer = await getItem('manufacturers', brassItem.manufacturerId);
                const option = document.createElement('option');
                option.value = brassItem.id;
                option.textContent = manufacturer ? manufacturer.name : 'N/A';
                brassSelect.appendChild(option);
            }
            brassSelect.value = oldValue;
        }

        async function refreshPowderNameDropdown() {
            const manufacturerId = document.getElementById('loadPowderManufacturer').value;
            const allPowders = await getAllItems('powders');
            const powderSelect = document.getElementById('loadPowder');
            
            const filteredPowders = manufacturerId ? allPowders.filter(p => p.manufacturerId === manufacturerId) : [];
            
            const oldValue = powderSelect.value;
            powderSelect.innerHTML = '<option value="">-- Select --</option>';
            for (const powder of filteredPowders) {
                const option = document.createElement('option');
                option.value = powder.id;
                option.textContent = powder.name;
                powderSelect.appendChild(option);
            }
            powderSelect.value = oldValue;
        }

        async function refreshCommercialAmmoCartridgeDropdown() {
            const diameterId = document.getElementById('commercialAmmoDiameter').value;
            const allCartridges = await getAllItems('cartridges');
            const filteredCartridges = diameterId
                ? allCartridges.filter(c => c.diameterId === diameterId)
                : []; 
            populateSelect('commercialAmmoCartridge', filteredCartridges, 'name', 'id');
        }

        function initLoadsManagement() {
            document.getElementById('loadForm').addEventListener('submit', handleLoadSubmit);
            document.getElementById('loadForm').addEventListener('reset', () => document.getElementById('loadId').value = '');
            document.getElementById('loadsTableBody').addEventListener('click', handleLoadTableClick);
            
            document.getElementById('loadDiameter').addEventListener('change', async () => {
                await refreshLoadCartridgeDropdown();
                await refreshBrassDropdownForLoad();
                await refreshBulletWeightDropdown();
            });
            document.getElementById('loadCartridge').addEventListener('change', refreshBrassDropdownForLoad);
            document.getElementById('loadBulletWeight').addEventListener('change', refreshBulletNameDropdown);
            document.getElementById('loadPowderManufacturer').addEventListener('change', refreshPowderNameDropdown);

            const subTabContainer = document.querySelector('#loads .tabs-nav');
            const subTabContents = document.querySelectorAll('#load-forms-container .tab-content');
            subTabContainer.addEventListener('click', (e) => {
                if(e.target && e.target.classList.contains('sub-tab-link')) {
                    e.preventDefault();
                    const subTabId = e.target.getAttribute('data-subtab');
                    subTabContainer.querySelectorAll('.sub-tab-link').forEach(l => l.classList.remove('active'));
                    e.target.classList.add('active');
                    subTabContents.forEach(content => {
                        content.classList.remove('active');
                        if (content.id === `${subTabId}-subtab`) { content.classList.add('active'); }
                    });
                    document.getElementById('loadForm').reset();
                    document.getElementById('commercialAmmoForm').reset();
                    document.getElementById('loadId').value = '';
                    document.getElementById('commercialAmmoId').value = '';
                }
            });

            document.getElementById('commercialAmmoForm').addEventListener('submit', handleCommercialAmmoSubmit);
            document.getElementById('commercialAmmoForm').addEventListener('reset', () => document.getElementById('commercialAmmoId').value = '');
            document.getElementById('commercialAmmoDiameter').addEventListener('change', refreshCommercialAmmoCartridgeDropdown);

            refreshLoadsUI();
        }
        
        async function refreshLoadsUI() {
            const allDiameters = await getAllItems('diameters');
            const allPrimers = await getAllItems('primers');
            const allManufacturers = await getAllItems('manufacturers');
            
            // Handload Form: Populate only the non-dependent dropdowns
            populateSelect('loadDiameter', allDiameters, 'imperial', 'id');
            populateSelect('loadPrimer', allPrimers, 'name', 'id');
            const powderManufacturers = allManufacturers.filter(m => m.type && m.type.includes('powder'));
            populateSelect('loadPowderManufacturer', powderManufacturers, 'name', 'id');
            
            // Clear dependent dropdowns to ensure a fresh start
            document.getElementById('loadCartridge').innerHTML = '<option value="">-- Select --</option>';
            document.getElementById('loadBulletWeight').innerHTML = '<option value="">-- Select --</option>';
            document.getElementById('loadBullet').innerHTML = '<option value="">-- Select --</option>';
            document.getElementById('loadPowder').innerHTML = '<option value="">-- Select --</option>';
            document.getElementById('loadBrass').innerHTML = '<option value="">-- Select --</option>';

            // Commercial Ammo Form
            populateSelect('commercialAmmoManufacturer', allManufacturers, 'name', 'id');
            populateSelect('commercialAmmoDiameter', allDiameters, 'imperial', 'id');
            await refreshCommercialAmmoCartridgeDropdown();

            renderLoadsTable();
        }

        async function handleLoadSubmit(e) {
            e.preventDefault();
            const load = {
                id: document.getElementById('loadId').value || generateUniqueId(),
                loadType: 'handload',
                cartridgeId: document.getElementById('loadCartridge').value,
                diameterId: document.getElementById('loadDiameter').value,
                bulletId: document.getElementById('loadBullet').value,
                bulletLot: document.getElementById('loadBulletLot').value,
                powderId: document.getElementById('loadPowder').value,
                powderLot: document.getElementById('loadPowderLot').value,
                chargeWeight: parseFloat(document.getElementById('loadChargeWeight').value),
                col: parseFloat(document.getElementById('loadCol').value),
                cbto: parseFloat(document.getElementById('loadCbto').value),
                primerId: document.getElementById('loadPrimer').value,
                primerLot: document.getElementById('loadPrimerLot').value,
                brassId: document.getElementById('loadBrass').value,
                brassLot: document.getElementById('loadBrassLot').value,
                firings: parseInt(document.getElementById('loadFirings').value)
            };
            await updateItem('loads', load);
            e.target.reset();
            renderLoadsTable();
            refreshImpactMarkingUI();
        }

        async function handleCommercialAmmoSubmit(e) {
            e.preventDefault();
            const ammo = {
                id: document.getElementById('commercialAmmoId').value || generateUniqueId(),
                loadType: 'commercial',
                manufacturerId: document.getElementById('commercialAmmoManufacturer').value,
                name: document.getElementById('commercialAmmoName').value,
                diameterId: document.getElementById('commercialAmmoDiameter').value,
                cartridgeId: document.getElementById('commercialAmmoCartridge').value,
                bulletWeight: parseFloat(document.getElementById('commercialAmmoBulletWeight').value),
                lot: document.getElementById('commercialAmmoLot').value,
            };
            await updateItem('loads', ammo);
            e.target.reset();
            renderLoadsTable();
            refreshImpactMarkingUI();
        }

        async function renderLoadsTable() {
            const [
                loads, cartridges, bullets, powders, manufacturers
            ] = await Promise.all([
                getAllItems('loads'),
                getAllItems('cartridges'),
                getAllItems('bullets'),
                getAllItems('powders'),
                getAllItems('manufacturers')
            ]);

            const cartridgeMap = new Map(cartridges.map(i => [i.id, i.name]));
            const manufacturerMap = new Map(manufacturers.map(i => [i.id, i.name]));
            const powderMap = new Map(powders.map(i => [i.id, i.name]));
            
            const bulletMap = new Map(bullets.map(i => {
                const mfgName = manufacturerMap.get(i.manufacturerId) || '';
                const text = `${i.weight}gr ${mfgName} ${i.name}`;
                return [i.id, text];
            }));

            const tableBody = document.getElementById('loadsTableBody');
            tableBody.innerHTML = '';

            for (const load of loads) {
                let type, details, charge, colCbto;
                const cartridgeName = cartridgeMap.get(load.cartridgeId) || 'N/A';

                if (load.loadType === 'commercial') {
                    type = 'Commercial';
                    const mfgName = manufacturerMap.get(load.manufacturerId) || '';
                    details = `${mfgName} ${load.name} ${load.bulletWeight || ''}gr`.trim();
                    charge = 'N/A';
                    colCbto = 'N/A';
                } else { // Handload or legacy data
                    type = 'Hand Load';
                    details = bulletMap.get(load.bulletId) || 'N/A';
                    charge = `${load.chargeWeight || ''} gr ${powderMap.get(load.powderId) || ''}`.trim();
                    colCbto = `${load.col ? load.col.toFixed(3) : '---'} / ${load.cbto ? load.cbto.toFixed(3) : '---'}`;
                }

                const row = `
                    <tr>
                        <td>${type}</td>
                        <td>${cartridgeName}</td>
                        <td>${details}</td>
                        <td>${charge}</td>
                        <td>${colCbto}</td>
                        <td>
                            <div class="flex-container">
                                <button class="btn-yellow btn-small" data-id="${load.id}" data-action="edit">Edit</button>
                                <button class="btn-red btn-small" data-id="${load.id}" data-action="delete">Delete</button>
                            </div>
                        </td>
                    </tr>`;
                tableBody.insertAdjacentHTML('beforeend', row);
            }
        }
        
        async function handleLoadTableClick(e) {
            const { id, action } = e.target.dataset;
            if (!id || !action) return;

            if (action === 'delete') {
                if (confirm('Are you sure?')) { 
                    await deleteItem('loads', id); 
                    renderLoadsTable(); 
                    refreshImpactMarkingUI();
                }
            } else if (action === 'edit') {
                const item = await getItem('loads', id);
                
                const subTabContainer = document.querySelector('#loads .tabs-nav');
                const subTabContents = document.querySelectorAll('#load-forms-container .tab-content');
                const targetTab = item.loadType === 'commercial' ? 'commercial-ammo' : 'hand-load';
                
                subTabContainer.querySelectorAll('.sub-tab-link').forEach(l => {
                    l.classList.toggle('active', l.dataset.subtab === targetTab);
                });
                subTabContents.forEach(content => {
                    content.classList.toggle('active', content.id === `${targetTab}-subtab`);
                });

                if (item.loadType === 'commercial') {
                    document.getElementById('commercialAmmoId').value = item.id;
                    document.getElementById('commercialAmmoManufacturer').value = item.manufacturerId;
                    document.getElementById('commercialAmmoName').value = item.name;
                    document.getElementById('commercialAmmoDiameter').value = item.diameterId;
                    await refreshCommercialAmmoCartridgeDropdown();
                    document.getElementById('commercialAmmoCartridge').value = item.cartridgeId;
                    document.getElementById('commercialAmmoBulletWeight').value = item.bulletWeight;
                    document.getElementById('commercialAmmoLot').value = item.lot;
                } else {
                    document.getElementById('loadForm').reset();
                    document.getElementById('loadId').value = item.id;
                    
                    document.getElementById('loadDiameter').value = item.diameterId;
                    await refreshLoadCartridgeDropdown();
                    document.getElementById('loadCartridge').value = item.cartridgeId;
                    
                    const bullet = await getItem('bullets', item.bulletId);
                    await refreshBulletWeightDropdown();
                    if (bullet) {
                        document.getElementById('loadBulletWeight').value = bullet.weight;
                    }

                    await refreshBulletNameDropdown();
                    document.getElementById('loadBullet').value = item.bulletId;
                    document.getElementById('loadBulletLot').value = item.bulletLot;
                    
                    const powder = await getItem('powders', item.powderId);
                    if (powder) {
                        document.getElementById('loadPowderManufacturer').value = powder.manufacturerId;
                    }
                    await refreshPowderNameDropdown();
                    document.getElementById('loadPowder').value = item.powderId;
                    document.getElementById('loadPowderLot').value = item.powderLot;
                    document.getElementById('loadChargeWeight').value = item.chargeWeight;
                    
                    document.getElementById('loadPrimer').value = item.primerId;
                    document.getElementById('loadPrimerLot').value = item.primerLot;
                    document.getElementById('loadCol').value = item.col;
                    document.getElementById('loadCbto').value = item.cbto;

                    await refreshBrassDropdownForLoad();
                    document.getElementById('loadBrass').value = item.brassId;
                    document.getElementById('loadBrassLot').value = item.brassLot;
                    document.getElementById('loadFirings').value = item.firings;
                }
            }
        }
        
        // --- TARGETS MANAGEMENT LOGIC ---
        async function renderTargetImages() {
            const targetGallery = document.getElementById('targetGallery');
            const items = await getAllItems('targetImages');
            items.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            targetGallery.innerHTML = '';
            if (items.length === 0) {
                targetGallery.innerHTML = '<p style="color: #9ca3af; grid-column: 1 / -1; text-align: center;">No targets uploaded yet. Use the button above to add some.</p>';
                return;
            }
            
            items.forEach(item => {
                const cardHtml = `
                    <div class="card" data-id="${item.id}">
                        <img src="${item.dataUrl}" alt="${item.name}" style="width: 100%; aspect-ratio: 1 / 1.4; object-fit: contain; border-radius: 0.25rem; background-color: #374151;">
                        <input type="text" value="${item.name}" class="target-name-input" style="margin-top: 0.5rem;">
                        <div class="flex-container" style="margin-top: 0.5rem;">
                            <button class="btn-yellow btn-small" data-action="rename">Rename</button>
                            <button class="btn-red btn-small" data-action="delete">Delete</button>
                        </div>
                    </div>
                `;
                targetGallery.insertAdjacentHTML('beforeend', cardHtml);
            });
        }

        function initTargetsManagement() {
            const uploadInput = document.getElementById('uploadTargetImage');
            const targetGallery = document.getElementById('targetGallery');

            uploadInput.addEventListener('change', handleTargetUpload);
            targetGallery.addEventListener('click', handleGalleryClick);

            async function handleTargetUpload(e) {
                const files = e.target.files;
                for (const file of files) {
                    if (!file.type.startsWith('image/')) continue;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const webpDataUrl = await convertToWebP(event.target.result);
                            const targetData = {
                                id: generateUniqueId(),
                                name: file.name.replace(/\.[^/.]+$/, "") + '.webp',
                                dataUrl: webpDataUrl,
                                timestamp: new Date().toISOString()
                            };
                            await updateItem('targetImages', targetData);
                            await renderTargetImages();
                            await refreshImpactMarkingUI();
                        } catch (error) {
                            console.error("Failed to process and save image:", error);
                            alert("There was an error converting the image to WebP format.");
                        }
                    };
                    reader.readAsDataURL(file);
                }
                e.target.value = '';
            }
            
            async function handleGalleryClick(e) {
                const button = e.target.closest('button[data-action]');
                if (!button) return;
                
                const card = button.closest('[data-id]');
                const id = card.dataset.id;
                const action = button.dataset.action;

                if (action === 'delete') {
                    if (confirm('Are you sure you want to delete this target?')) {
                        await deleteItem('targetImages', id);
                        await renderTargetImages();
                        await refreshImpactMarkingUI();
                    }
                } else if (action === 'rename') {
                    const nameInput = card.querySelector('.target-name-input');
                    const newName = nameInput.value;
                    const item = await getItem('targetImages', id);
                    if (item) {
                        item.name = newName;
                        await updateItem('targetImages', item);
                        alert('Target renamed.');
                        await renderTargetImages();
                        await refreshImpactMarkingUI();
                    }
                }
            }
            renderTargetImages();
        }

        // --- IMPACT MARKING LOGIC ---

        async function refreshImpactMarkingUI() {
            const firearms = await getAllItems('firearms');
            populateSelect('firearmSelect', firearms, 'nickname', 'id');

            const loads = await getAllItems('loads');
            const loadSelect = document.getElementById('loadSelect');
            const currentLoadVal = loadSelect.value;
            loadSelect.innerHTML = '<option value="">-- Associate Load (Optional) --</option>';
            for (const load of loads) {
                const option = document.createElement('option');
                option.value = load.id;
                
                if (load.loadType === 'commercial') {
                    const mfg = await getItem('manufacturers', load.manufacturerId);
                    option.textContent = `${mfg ? mfg.name : ''} ${load.name} ${load.bulletWeight || ''}gr`.trim();
                } else {
                    const bullet = await getItem('bullets', load.bulletId);
                    const powder = await getItem('powders', load.powderId);
                    let bulletName = 'Unknown Bullet';
                    if (bullet) {
                        const bulletMfg = await getItem('manufacturers', bullet.manufacturerId);
                        bulletName = `${bullet.weight}gr ${bulletMfg ? bulletMfg.name : ''} ${bullet.name}`;
                    }
                    const powderName = powder ? powder.name : 'Unknown Powder';
                    option.textContent = `(HL) ${bulletName} | ${powderName} ${load.chargeWeight}gr`;
                }
                loadSelect.appendChild(option);
            }
            loadSelect.value = currentLoadVal;
            
            const savedImageSelect = document.getElementById('savedImageSelect');
            const targets = await getAllItems('targetImages');
            const currentTargetVal = savedImageSelect.value;
            savedImageSelect.innerHTML = '<option value="">-- Select a Saved Target --</option>';
            targets.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            targets.forEach(target => {
                const option = document.createElement('option');
                option.value = target.id;
                option.textContent = target.name;
                savedImageSelect.appendChild(option);
            });
            savedImageSelect.value = currentTargetVal;
        }

        function initImpactMarking() {
            const canvas = document.getElementById('targetCanvas');
            const ctx = canvas.getContext('2d');
            const savedImageSelect = document.getElementById('savedImageSelect');
            const markingSessionSelect = document.getElementById('markingSessionSelect');
            const loadMarkingSessionBtn = document.getElementById('loadMarkingSessionBtn');
            const deleteMarkingSessionBtn = document.getElementById('deleteMarkingSessionBtn');
            const removeImageBtn = document.getElementById('removeImage');
            const zoomInBtn = document.getElementById('zoomIn');
            const zoomOutBtn = document.getElementById('zoomOut');
            const setScaleBtn = document.getElementById('setScale');
            const addGroupBtn = document.getElementById('addGroup');
            const groupSelect = document.getElementById('groupSelect');
            const setPoaBtn = document.getElementById('setPoa');
            const setPoiBtn = document.getElementById('setPoi');
            const deleteShotBtn = document.getElementById('deleteShot');
            const deleteLastBtn = document.getElementById('deleteLast');
            const deleteGroupBtn = document.getElementById('deleteGroup');
            const statsOutput = document.getElementById('stats-output');
            const toggleButtons = [setScaleBtn, setPoaBtn, setPoiBtn, deleteShotBtn];
            const saveImpactDataBtn = document.getElementById('saveImpactDataBtn');
            
            let img = null;
            let scale = { p1: null, p2: null, distance: null, units: 'in', pixelsPerUnit: null };
            let groups = [];
            let currentGroupIndex = -1;
            let settingState = null;
            let sessionID = null;
            let currentTargetId = null;
            
            let transform = { x: 0, y: 0, scale: 1 };
            let isPanning = false;
            let panStart = { x: 0, y: 0 };
            let mousePos = { x: 0, y: 0 };
            
            async function populateMarkingSessionSelect() {
                const sessions = await getAllItems('impactData');
                sessions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                const currentVal = markingSessionSelect.value;
                markingSessionSelect.innerHTML = `<option value="">-- Select a Session to load/delete --</option>`;
                for(const session of sessions) {
                    const option = document.createElement('option');
                    option.value = session.id;
                    option.textContent = await createSessionName(session);
                    markingSessionSelect.appendChild(option);
                }
                markingSessionSelect.value = currentVal;
            }
            
            refreshImpactMarkingUI().then(populateMarkingSessionSelect);
            resetCanvasState();

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(transform.x, transform.y);
                ctx.scale(transform.scale, transform.scale);

                if (img) { ctx.drawImage(img, 0, 0, img.scaledWidth, img.scaledHeight); }

                if (settingState === 'scale_p2' && scale.p1) {
                    ctx.beginPath();
                    ctx.moveTo(scale.p1.x, scale.p1.y);
                    const currentMouse = getCanvasCoords({clientX: mousePos.x, clientY: mousePos.y});
                    ctx.lineTo(currentMouse.x, currentMouse.y);
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                    ctx.lineWidth = 2 / transform.scale;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                if (scale.p1 && scale.p2) {
                    ctx.beginPath();
                    ctx.moveTo(scale.p1.x, scale.p1.y);
                    ctx.lineTo(scale.p2.x, scale.p2.y);
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2 / transform.scale;
                    ctx.stroke();
                }

                groups.forEach((group) => {
                    if (group.poa) { drawPOA(group.poa, group.color); }
                    group.pois.forEach(poi => drawCircle(poi, group.color));
                    if (group.stats && group.stats.mpi && group.pois.length > 0) {
                        drawMPI(group.stats.mpi, group.color);
                    }
                });

                ctx.restore();
            }
            
            function drawCircle(point, color) {
                const radius = 8 / transform.scale;
                ctx.beginPath();
                ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
            }

            function drawPOA(point, color) {
                const size = 16 / transform.scale;
                ctx.beginPath();
                ctx.moveTo(point.x - size / 2, point.y);
                ctx.lineTo(point.x + size / 2, point.y);
                ctx.moveTo(point.x, point.y - size / 2);
                ctx.lineTo(point.x, point.y + size / 2);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2 / transform.scale;
                ctx.stroke();
            }

            function drawMPI(point, color) {
                const size = 16 / transform.scale;
                ctx.beginPath();
                ctx.rect(point.x - size / 2, point.y - size / 2, size, size);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2 / transform.scale;
                ctx.stroke();
            }
            
            function getCanvasCoords(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const canvasX = (e.clientX - rect.left) * scaleX;
                const canvasY = (e.clientY - rect.top) * scaleY;
                const finalX = (canvasX - transform.x) / transform.scale;
                const finalY = (canvasY - transform.y) / transform.scale;
                return { x: finalX, y: finalY };
            }

            function updateActiveButton(activeButton) {
                toggleButtons.forEach(btn => btn.classList.remove('active'));
                if (activeButton) {
                    activeButton.classList.add('active');
                }
                canvas.classList.toggle('delete-mode', settingState === 'delete_poi');
            }

            savedImageSelect.addEventListener('change', async (e) => {
                const targetId = e.target.value;
                if (!targetId) {
                    img = null;
                    currentTargetId = null;
                    resetCanvasState();
                    return;
                }
                
                const targetData = await getItem('targetImages', targetId);
                if (targetData) {
                    img = new Image();
                    img.onload = () => { 
                        currentTargetId = targetId;
                        const aspectRatio = img.naturalHeight / img.naturalWidth;
                        img.scaledWidth = canvas.width;
                        img.scaledHeight = canvas.width * aspectRatio;
                        if (!sessionID) { resetCanvasState(); } // Reset only if not loading a session
                    };
                    img.src = targetData.dataUrl;
                }
            });
            
            removeImageBtn.addEventListener('click', () => {
                img = null;
                resetCanvasState();
                savedImageSelect.value = '';
                markingSessionSelect.value = '';
                currentTargetId = null;
                statsOutput.innerHTML = '<p>Impact data will appear here once you mark points and set a scale.</p>';
            });

            function resetCanvasState() {
                transform = { x: 0, y: 0, scale: 1 };
                scale = { p1: null, p2: null, distance: null, units: 'in', pixelsPerUnit: null };
                groups = [];
                currentGroupIndex = -1;
                settingState = null;
                sessionID = generateUniqueId();
                renderGroupSelector();
                updateActiveButton(null);
                updateStatsDisplay();
            }

            zoomInBtn.addEventListener('click', () => { transform.scale *= 1.2; });
            zoomOutBtn.addEventListener('click', () => { transform.scale /= 1.2; });

            canvas.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                if (!settingState) {
                    isPanning = true;
                    panStart = { x: e.clientX - transform.x, y: e.clientY - transform.y };
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (isPanning) {
                    isPanning = false;
                    return;
                }
                if (!settingState) return;

                const coords = getCanvasCoords(e);

                if (settingState === 'scale_p1') {
                    scale.p1 = coords;
                    settingState = 'scale_p2';
                } else if (settingState === 'scale_p2') {
                    scale.p2 = coords;
                    const pixelDist = Math.hypot(scale.p2.x - scale.p1.x, scale.p2.y - scale.p1.y);
                    const realDist = parseFloat(document.getElementById('scaleDistance').value);
                    if (pixelDist > 0 && realDist > 0) {
                        scale.distance = realDist;
                        scale.units = document.getElementById('scaleUnits').value;
                        scale.pixelsPerUnit = pixelDist / realDist;
                    } else {
                        scale.p1 = null; scale.p2 = null;
                    }
                    settingState = null;
                    updateActiveButton(null);
                    updateStatsDisplay();
                } else if (settingState === 'poa' && currentGroupIndex !== -1) {
                    groups[currentGroupIndex].poa = coords;
                    settingState = 'poi';
                    updateActiveButton(setPoiBtn);
                    updateStatsDisplay();
                } else if (settingState === 'poi' && currentGroupIndex !== -1) {
                    groups[currentGroupIndex].pois.push({x: coords.x, y: coords.y, velocity: null});
                    updateStatsDisplay();
                } else if (settingState === 'delete_poi') {
                    const clickRadius = 10 / transform.scale;
                    let deleted = false;
                    for (const group of groups) {
                        const pois = group.pois;
                        for (let i = pois.length - 1; i >= 0; i--) {
                            const dist = Math.hypot(coords.x - pois[i].x, coords.y - pois[i].y);
                            if (dist < clickRadius) {
                                pois.splice(i, 1);
                                deleted = true;
                                break;
                            }
                        }
                        if (deleted) break;
                    }
                    if (deleted) {
                        updateStatsDisplay();
                    }
                }
            });

            canvas.addEventListener('mouseleave', () => { isPanning = false; });
            canvas.addEventListener('mousemove', (e) => {
                mousePos = { x: e.clientX, y: e.clientY };
                if (isPanning) { transform.x = e.clientX - panStart.x; transform.y = e.clientY - panStart.y; }
            });
            
            setScaleBtn.addEventListener('click', () => {
                if (settingState === 'scale_p1' || settingState === 'scale_p2') {
                    settingState = null;
                    updateActiveButton(null);
                    scale.p1 = null;
                    return;
                }
                const dist = document.getElementById('scaleDistance').value;
                if (!img || !dist || parseFloat(dist) <= 0) {
                    alert('Please load a saved image and enter a valid scale distance first.');
                    return;
                }
                settingState = 'scale_p1';
                updateActiveButton(setScaleBtn);
            });

            function renderGroupSelector() {
                groupSelect.innerHTML = '';
                groups.forEach((group, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `Group ${index + 1}`;
                    groupSelect.appendChild(option);
                });
                groupSelect.value = currentGroupIndex;
            }

            addGroupBtn.addEventListener('click', () => {
                if (!img) { alert('Please load a saved image first.'); return; }
                const colors = ['#36A2EB', '#FFCE56', '#9966FF', '#FF9F40', '#f472b6', '#6b7280'];
                groups.push({ pois: [], poa: null, color: colors[groups.length % colors.length], stats: {} });
                currentGroupIndex = groups.length - 1;
                renderGroupSelector();
                settingState = 'poa'; 
                updateActiveButton(setPoaBtn); 
                updateStatsDisplay();
            });

            deleteGroupBtn.addEventListener('click', () => {
                if (currentGroupIndex === -1) return;
                groups.splice(currentGroupIndex, 1);
                if (currentGroupIndex >= groups.length) {
                    currentGroupIndex = groups.length - 1;
                }
                if (groups.length === 0) {
                    settingState = null;
                    updateActiveButton(null);
                }
                renderGroupSelector();
                updateStatsDisplay();
            });

            groupSelect.addEventListener('change', () => {
                currentGroupIndex = parseInt(groupSelect.value, 10);
                updateStatsDisplay();
            });

            setPoaBtn.addEventListener('click', () => {
                if (settingState === 'poa') {
                    settingState = null;
                    updateActiveButton(null);
                } else {
                    if (currentGroupIndex === -1) { 
                        alert('Please add or select a group first.');
                        return;
                    }
                    settingState = 'poa';
                    updateActiveButton(setPoaBtn);
                }
            });

            setPoiBtn.addEventListener('click', () => {
                if (settingState === 'poi') {
                    settingState = null;
                    updateActiveButton(null);
                } else {
                    if (currentGroupIndex === -1) { addGroupBtn.click(); }
                    settingState = 'poi';
                    updateActiveButton(setPoiBtn);
                }
            });

            deleteShotBtn.addEventListener('click', () => {
                if (settingState === 'delete_poi') {
                    settingState = null;
                    updateActiveButton(null);
                } else {
                    settingState = 'delete_poi';
                    updateActiveButton(deleteShotBtn);
                }
            });

            deleteLastBtn.addEventListener('click', () => {
                if (currentGroupIndex !== -1 && groups[currentGroupIndex].pois.length > 0) {
                    groups[currentGroupIndex].pois.pop();
                    updateStatsDisplay();
                }
            });
            
            function calculateGroupStats(pois) {
                if (pois.length < 1) { return {}; }
                const n = pois.length;
                const mpi = { x: pois.reduce((s, p) => s + p.x, 0) / n, y: pois.reduce((s, p) => s + p.y, 0) / n };
                return { mpi, shotCount: n };
            }

            async function handleSaveImpactData() {
                updateStatsDisplay(); 

                if (!scale.pixelsPerUnit) {
                    alert("Please set the scale first to save meaningful coordinate data for analysis.");
                }
                
                if (groups.length === 0 || groups.every(g => g.pois.length === 0)) {
                    alert("No impacts have been marked. Nothing to save.");
                    return;
                }

                // Calculate relative shots for analysis tab
                const shotsForAnalysis = [];
                let shotCounter = 0;
                if(scale.pixelsPerUnit){
                    groups.forEach((group, groupIndex) => {
                        if (group.pois.length > 0 && group.poa) {
                            group.pois.forEach((poi) => {
                                shotCounter++;
                                const x_coord = (poi.x - group.poa.x) / scale.pixelsPerUnit;
                                const y_coord = (poi.y - group.poa.y) / scale.pixelsPerUnit;
                                shotsForAnalysis.push({
                                    shotNumber: shotCounter, group: groupIndex + 1,
                                    x: parseFloat(x_coord.toFixed(4)), y: parseFloat(y_coord.toFixed(4)),
                                    units: scale.units, velocity: poi.velocity
                                });
                            });
                        }
                    });
                }
                
                const sessionData = {
                    id: sessionID,
                    timestamp: new Date().toISOString(),
                    targetImageId: currentTargetId,
                    firearmId: document.getElementById('firearmSelect').value || null,
                    loadId: document.getElementById('loadSelect').value || null,
                    targetDistance: parseFloat(document.getElementById('tmTargetDistance').value) || null,
                    distanceUnits: document.getElementById('tmDistanceUnits').value,
                    groups: groups, // for re-loading in marking tab
                    scale: scale,     // for re-loading in marking tab
                    shots: shotsForAnalysis // for analysis tab
                };
                
                try {
                    await updateItem('impactData', sessionData);
                    alert('Session data saved successfully!');
                    await populateMarkingSessionSelect();
                    document.getElementById('sessionSelect').dispatchEvent(new Event('refresh'));
                } catch (error) {
                    console.error("Failed to save impact data:", error);
                    alert("An error occurred while saving the session data.");
                }
            }
            saveImpactDataBtn.addEventListener('click', handleSaveImpactData);

            loadMarkingSessionBtn.addEventListener('click', async () => {
                const sessionIdToLoad = markingSessionSelect.value;
                if (!sessionIdToLoad) {
                    alert('Please select a session to load.');
                    return;
                }
                const data = await getItem('impactData', sessionIdToLoad);
                if (!data) {
                    alert('Could not find the selected session data.');
                    return;
                }

                removeImageBtn.click(); // Full reset before loading

                // Wait for reset to complete
                await new Promise(resolve => setTimeout(resolve, 50));

                sessionID = data.id;
                scale = data.scale || { p1: null, p2: null, distance: null, units: 'in', pixelsPerUnit: null };
                groups = data.groups || [];
                currentGroupIndex = groups.length > 0 ? 0 : -1;
                
                document.getElementById('firearmSelect').value = data.firearmId;
                document.getElementById('loadSelect').value = data.loadId;
                document.getElementById('tmTargetDistance').value = data.targetDistance;
                document.getElementById('tmDistanceUnits').value = data.distanceUnits;
                document.getElementById('scaleDistance').value = scale.distance;
                document.getElementById('scaleUnits').value = scale.units;

                if (data.targetImageId) {
                    savedImageSelect.value = data.targetImageId;
                    savedImageSelect.dispatchEvent(new Event('change'));
                }
                
                renderGroupSelector();
                updateStatsDisplay();
            });

            deleteMarkingSessionBtn.addEventListener('click', async () => {
                const sessionIdToDelete = markingSessionSelect.value;
                if (!sessionIdToDelete) {
                    alert('Please select a session to delete.');
                    return;
                }

                if (confirm(`Are you sure you want to permanently delete session ${sessionIdToDelete.substring(0,8)}?`)) {
                    await deleteItem('impactData', sessionIdToDelete);
                    
                    // If the deleted session is the one currently loaded, clear the canvas
                    if (sessionID === sessionIdToDelete) {
                        removeImageBtn.click();
                    }

                    await populateMarkingSessionSelect();
                    document.getElementById('sessionSelect').dispatchEvent(new Event('refresh'));
                    alert('Session deleted.');
                }
            });

            statsOutput.addEventListener('input', (e) => {
                if (e.target.classList.contains('velocity-input-tm')) {
                    const groupIndex = parseInt(e.target.dataset.groupIndex, 10);
                    const poiIndex = parseInt(e.target.dataset.poiIndex, 10);
                    const value = e.target.value === '' ? null : parseFloat(e.target.value);
                    
                    if (groups[groupIndex] && groups[groupIndex].pois[poiIndex]) {
                        groups[groupIndex].pois[poiIndex].velocity = value;
                    }
                }
            });

            function updateStatsDisplay() {
                groups.forEach(group => {
                    group.stats = calculateGroupStats(group.pois);
                });
                
                let hasImpacts = groups.some(group => group.pois.length > 0);
                
                let html = '';

                if (hasImpacts) {
                     let impactListHtml = '<ul class="impact-data-list">';
                     let shotCounter = 0;
                     groups.forEach((group, groupIndex) => {
                        if (group.pois.length > 0) {
                            const referencePoint = group.poa;
                            group.pois.forEach((poi, poiIndex) => {
                                shotCounter++;
                                let coordText = '<i>(Set POA & Scale for coords)</i>';
                                if (referencePoint && scale.pixelsPerUnit) {
                                    const x_coord = (poi.x - referencePoint.x) / scale.pixelsPerUnit;
                                    const y_coord = (poi.y - referencePoint.y) / scale.pixelsPerUnit;
                                    coordText = `X: ${x_coord.toFixed(3)}, Y: ${y_coord.toFixed(3)}`;
                                }
                                impactListHtml += `
                                    <li>
                                        <span>
                                            <b>Shot ${shotCounter} (G${groupIndex+1}):</b> 
                                            ${coordText}
                                        </span>
                                        <input type="number" class="velocity-input-tm" 
                                               data-group-index="${groupIndex}" 
                                               data-poi-index="${poiIndex}" 
                                               value="${poi.velocity !== null ? poi.velocity : ''}" 
                                               placeholder="fps/mps">
                                    </li>
                                `;
                            });
                        }
                     });
                     impactListHtml += '</ul>';
                     html += impactListHtml;
                }

                if (html === '') {
                    statsOutput.innerHTML = '<p>Impact data will appear here once you mark points and set a scale.</p>';
                } else {
                    statsOutput.innerHTML = html;
                }
            }

            function animationLoop() { 
                draw(); 
                requestAnimationFrame(animationLoop); 
            }
            animationLoop();
        }
        
        // --- STATISTICAL ANALYSIS LOGIC ---
        function initStatisticalAnalysis() {
            const sessionSelect = document.getElementById('sessionSelect');
            const firearmFilterSelect = document.getElementById('firearmFilterSelect');
            const compareBtn = document.getElementById('compareSessionsBtn');
            const exportBtn = document.getElementById('exportAnalysisBtn');
            const statOutputContainer = document.getElementById('statAnalysisOutput');
            const plotContainer = document.getElementById('analysisPlotContainer');
            let lastAnalysisResults = [];
            const colors = ['#22c55e', '#3b82f6', '#ef4444', '#eab308', '#a855f7', '#f97316'];

            async function populateFirearmFilter() {
                firearmFilterSelect.innerHTML = '<option value="">-- All Firearms --</option>';
                const firearms = await getAllItems('firearms');
                firearms.sort((a,b) => a.nickname.localeCompare(b.nickname));
                firearms.forEach(firearm => {
                    const option = document.createElement('option');
                    option.value = firearm.id;
                    option.textContent = firearm.nickname;
                    firearmFilterSelect.appendChild(option);
                });
            }

            async function populateSessionSelect(firearmId = null) {
                let sessions = await getAllItems('impactData');
                
                if (firearmId) {
                    sessions = sessions.filter(session => session.firearmId === firearmId);
                }

                sessions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                sessionSelect.innerHTML = ``;

                for(const session of sessions) {
                    if (!session.shots || session.shots.length < 2) continue;

                    const option = document.createElement('option');
                    option.value = session.id;
                    option.textContent = await createSessionName(session);
                    sessionSelect.appendChild(option);
                }
            }
            
            sessionSelect.addEventListener('refresh', async () => {
                await populateFirearmFilter();
                await populateSessionSelect(firearmFilterSelect.value);
            });
            
            firearmFilterSelect.addEventListener('change', (e) => {
                populateSessionSelect(e.target.value);
            });
            
            compareBtn.addEventListener('click', handleSessionComparison);
            exportBtn.addEventListener('click', handleAnalysisExport);

            function bootstrapMeanRadiusCI(shots, samples = 1000) {
                const n = shots.length;
                if (n < 2) return { lower: 0, upper: 0 };

                const bootstrapMeans = [];
                for (let i = 0; i < samples; i++) {
                    const bootstrapSample = [];
                    for (let j = 0; j < n; j++) {
                        bootstrapSample.push(shots[Math.floor(Math.random() * n)]);
                    }
                    
                    const mean_x = bootstrapSample.reduce((a, b) => a + b.x, 0) / n;
                    const mean_y = bootstrapSample.reduce((a, b) => a + b.y, 0) / n;
                    const meanRadius = bootstrapSample.reduce((sum, s) => sum + Math.hypot(s.x - mean_x, s.y - mean_y), 0) / n;
                    bootstrapMeans.push(meanRadius);
                }

                bootstrapMeans.sort((a, b) => a - b);
                const lowerIndex = Math.floor(samples * 0.025);
                const upperIndex = Math.floor(samples * 0.975);
                
                return { lower: bootstrapMeans[lowerIndex], upper: bootstrapMeans[upperIndex] };
            }

            function calculateLinearRegression(data) {
                let sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0, sum_y2 = 0;
                const n = data.length;
                if (n < 3) return { r: 0, r2: 0 };

                for (const point of data) {
                    sum_x += point.x;
                    sum_y += point.y;
                    sum_xy += point.x * point.y;
                    sum_x2 += point.x * point.x;
                    sum_y2 += point.y * point.y;
                }

                const numerator = (n * sum_xy) - (sum_x * sum_y);
                const denominator_x = (n * sum_x2) - (sum_x * sum_x);
                const denominator_y = (n * sum_y2) - (sum_y * sum_y);
                
                if (denominator_x === 0 || denominator_y === 0) {
                    return { r: 0, r2: 0 };
                }

                const r = numerator / Math.sqrt(denominator_x * denominator_y);
                return { r: r, r2: r * r };
            }

            function calculateStatsForSession(shots) {
                if (!shots || shots.length < 2) return null;

                const n = shots.length;
                const df = n - 1; 
                const dataUnits = shots[0].units || 'units';

                const all_x = shots.map(s => s.x);
                const all_y = shots.map(s => s.y);
                const mean_x = all_x.reduce((a, b) => a + b, 0) / n;
                const mean_y = all_y.reduce((a, b) => a + b, 0) / n;
                const sd_x = Math.sqrt(all_x.reduce((sum, x) => sum + Math.pow(x - mean_x, 2), 0) / df);
                const sd_y = Math.sqrt(all_y.reduce((sum, y) => sum + Math.pow(y - mean_y, 2), 0) / df);
                const meanRadius = shots.reduce((sum, s) => sum + Math.hypot(s.x - mean_x, s.y - mean_y), 0) / n;
                
                const hasVerticalDispersion = sd_y > sd_x * 1.5;

                const velocityShots = shots.filter(s => s.velocity !== null && typeof s.velocity === 'number' && !isNaN(s.velocity));
                let vel_es = null, vel_sd = null, vel_vert_r2 = null;

                if (velocityShots.length >= 2) {
                    const velocities = velocityShots.map(s => s.velocity);
                    vel_es = Math.max(...velocities) - Math.min(...velocities);
                    const mean_vel = velocities.reduce((a, b) => a + b, 0) / velocities.length;
                    const sum_sq_diff = velocities.reduce((acc, v) => acc + Math.pow(v - mean_vel, 2), 0);
                    vel_sd = Math.sqrt(sum_sq_diff / (velocities.length - 1));
                }

                if (velocityShots.length >= 3) {
                    const regressionData = velocityShots.map(s => ({ x: s.velocity, y: s.y }));
                    const regressionResult = calculateLinearRegression(regressionData);
                    vel_vert_r2 = regressionResult.r2;
                }

                const ci_mr = bootstrapMeanRadiusCI(shots);
                
                const relativeWidth = (ci_mr.upper - ci_mr.lower) / meanRadius;
                let confidence_level = 'Medium';
                let confidence_color = '#eab308'; // yellow

                if (relativeWidth > 0.75) {
                    confidence_level = 'Low';
                    confidence_color = '#ef4444'; // red
                } else if (relativeWidth < 0.35) {
                    confidence_level = 'High';
                    confidence_color = '#22c55e'; // green
                }
                
                return {
                    n: n,
                    units: dataUnits,
                    meanRadius: meanRadius,
                    sd_x: sd_x,
                    sd_y: sd_y,
                    vel_es: vel_es,
                    vel_sd: vel_sd,
                    vel_vert_r2: vel_vert_r2,
                    hasVerticalDispersion: hasVerticalDispersion,
                    ci_mean_radius: [ci_mr.lower, ci_mr.upper],
                    confidence_level: confidence_level,
                    confidence_color: confidence_color,
                    mpi: {x: mean_x, y: mean_y}
                };
            }

            async function handleSessionComparison() {
                const selectedIds = Array.from(sessionSelect.selectedOptions).map(option => option.value);

                if (selectedIds.length < 1) {
                    alert("Please select at least one session to analyze.");
                    return;
                }

                const results = [];
                for (const id of selectedIds) {
                    const sessionData = await getItem('impactData', id);
                    if (sessionData && sessionData.shots && sessionData.shots.length > 0) {
                        const stats = calculateStatsForSession(sessionData.shots);
                        if (stats) {
                            const sessionName = await createSessionName(sessionData);
                            results.push({
                                sessionId: id,
                                sessionName: sessionName,
                                stats: stats,
                                shots: sessionData.shots // Keep shots for plotting
                            });
                        }
                    }
                }
                
                results.sort((a, b) => a.stats.meanRadius - b.stats.meanRadius);
                
                renderComparisonTable(results);
                
                plotContainer.innerHTML = ''; 
                if (results.length > 0) {
                    lastAnalysisResults = results;
                    const plotCanvas = document.createElement('canvas');
                    plotCanvas.width = 800;
                    plotCanvas.height = 800;
                    plotCanvas.style.maxWidth = '100%';
                    plotCanvas.style.height = 'auto';
                    plotCanvas.style.backgroundColor = '#1f2937';
                    plotContainer.appendChild(plotCanvas);
                    await renderAnalysisPlot(results, plotCanvas);
                } else {
                    lastAnalysisResults = [];
                }
            }
            
            function renderComparisonTable(results) {
                statOutputContainer.innerHTML = '';
                if (results.length === 0) {
                    statOutputContainer.innerHTML = '<p style="text-align: center; padding: 1rem; color: #9ca3af;">No valid sessions found for analysis.</p>';
                    return;
                }
                
                const table = document.createElement('table');
                table.className = 'data-table';
                
                const thead = document.createElement('thead');
                thead.innerHTML = `
                    <tr>
                        <th>Session Details</th>
                        <th>Shots</th>
                        <th>MR</th>
                        <th>MR CI (Confidence)</th>
                        <th>Horiz. SD</th>
                        <th>Vert. SD</th>
                        <th>Vel. SD</th>
                        <th>Dispersion Analysis</th>
                    </tr>
                `;
                
                const tbody = document.createElement('tbody');
                results.forEach((result, index) => {
                    const stats = result.stats;
                    const color = colors[index % colors.length];
                    const row = document.createElement('tr');
                    
                    let analysisHtml = 'Nominal';
                    if (stats.hasVerticalDispersion) {
                        if (stats.vel_vert_r2 !== null) {
                            const r2_percent = (stats.vel_vert_r2 * 100).toFixed(1);
                            if (stats.vel_vert_r2 > 0.4) {
                                analysisHtml = `<span style="color: #f97316; font-weight: 500;">Vertical stringing correlates with velocity (R² = ${r2_percent}%)</span>`;
                            } else {
                                analysisHtml = `<span>Vertical stringing present, but not strongly correlated to velocity (R² = ${r2_percent}%)</span>`;
                            }
                        } else {
                            analysisHtml = `<span style="color: #eab308;">Vertical stringing detected. Add velocity data to diagnose.</span>`;
                        }
                    }

                    row.innerHTML = `
                        <td><span style="display: inline-block; vertical-align: middle; width: 12px; height: 12px; background-color: ${color}; margin-right: 8px; border-radius: 3px;"></span>${result.sessionName}</td>
                        <td>${stats.n}</td>
                        <td style="font-weight: 600;">${stats.meanRadius.toFixed(4)} ${stats.units}</td>
                        <td>[${stats.ci_mean_radius[0].toFixed(4)}, ${stats.ci_mean_radius[1].toFixed(4)}] <span style="color: ${stats.confidence_color}; font-weight: 600;">(${stats.confidence_level})</span></td>
                        <td>${stats.sd_x.toFixed(4)} ${stats.units}</td>
                        <td>${stats.sd_y.toFixed(4)} ${stats.units}</td>
                        <td>${stats.vel_sd !== null ? stats.vel_sd.toFixed(2) : 'N/A'}</td>
                        <td>${analysisHtml}</td>
                    `;
                    tbody.appendChild(row);
                });

                table.appendChild(thead);
                table.appendChild(tbody);
                statOutputContainer.appendChild(table);
            }
            
            async function renderAnalysisPlot(sessionResults, canvas, bounds = null) {
                const renderBounds = bounds || { x: 0, y: 0, width: canvas.width, height: canvas.height };
                const ctx = canvas.getContext('2d');
                
                ctx.save();
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(renderBounds.x, renderBounds.y, renderBounds.width, renderBounds.height);

                let maxOffset = 0;
                sessionResults.forEach(res => {
                    const sessionMPI = res.stats.mpi;
                    res.shots.forEach(shot => {
                        const offset = Math.hypot(shot.x - sessionMPI.x, shot.y - sessionMPI.y);
                        if (offset > maxOffset) maxOffset = offset;
                    });
                });

                const units = sessionResults[0].stats.units;
                const gridSpacing = (units === 'in') ? 1.0 : 25.0;
                let viewSpan = Math.ceil(maxOffset * 2 * 1.2 / gridSpacing) * gridSpacing;
                if (viewSpan === 0) viewSpan = gridSpacing * 4;

                const pixelsPerUnit = renderBounds.width / viewSpan;
                ctx.translate(renderBounds.x + renderBounds.width / 2, renderBounds.y + renderBounds.height / 2);

                const gridSpacingPx = gridSpacing * pixelsPerUnit;
                ctx.strokeStyle = '#374151';
                ctx.lineWidth = Math.max(1, renderBounds.width / 1000);
                for (let i = gridSpacingPx; i < renderBounds.width / 2; i += gridSpacingPx) {
                    ctx.beginPath();
                    ctx.moveTo(i, -renderBounds.height / 2); ctx.lineTo(i, renderBounds.height / 2);
                    ctx.moveTo(-i, -renderBounds.height / 2); ctx.lineTo(-i, renderBounds.height / 2);
                    ctx.stroke();
                }
                 for (let i = gridSpacingPx; i < renderBounds.height / 2; i += gridSpacingPx) {
                    ctx.beginPath();
                    ctx.moveTo(-renderBounds.width / 2, i); ctx.lineTo(renderBounds.width / 2, i);
                    ctx.moveTo(-renderBounds.width / 2, -i); ctx.lineTo(renderBounds.width / 2, -i);
                    ctx.stroke();
                }

                sessionResults.forEach((res, index) => {
                    const color = colors[index % colors.length];
                    const sessionMPI = res.stats.mpi;
                    const sessionMR = res.stats.meanRadius;

                    const radius = sessionMR * pixelsPerUnit;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = Math.max(2, renderBounds.width / 400);
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;

                    ctx.fillStyle = color;
                    const shotRadius = Math.max(3, renderBounds.width / 250);
                    res.shots.forEach(shot => {
                        const px = (shot.x - sessionMPI.x) * pixelsPerUnit;
                        const py = (shot.y - sessionMPI.y) * pixelsPerUnit * -1; // Flip Y for standard plot
                        ctx.beginPath();
                        ctx.arc(px, py, shotRadius, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                });

                ctx.strokeStyle = '#d1d5db';
                ctx.lineWidth = Math.max(2, renderBounds.width / 500);
                ctx.beginPath();
                ctx.moveTo(0, -renderBounds.height / 2); ctx.lineTo(0, renderBounds.height / 2);
                ctx.moveTo(-renderBounds.width / 2, 0); ctx.lineTo(renderBounds.width / 2, 0);
                ctx.stroke();

                ctx.restore();
            }

            async function handleAnalysisExport() {
                if (lastAnalysisResults.length === 0) {
                    alert("Please run an analysis first before exporting.");
                    return;
                }

                const DPI = 300;
                const IMG_WIDTH_INCHES = 8;
                const PLOT_HEIGHT_INCHES = 8;
                const ROW_HEIGHT_INCHES = 0.25;
                const HEADER_HEIGHT_INCHES = 0.4;
                const PADDING_INCHES = 0.2;
                const FONT_SIZE_PT = 12;

                const canvasWidth = IMG_WIDTH_INCHES * DPI;
                const plotHeight = PLOT_HEIGHT_INCHES * DPI;
                const rowHeight = ROW_HEIGHT_INCHES * DPI;
                const headerHeight = HEADER_HEIGHT_INCHES * DPI;
                const padding = PADDING_INCHES * DPI;

                const canvasHeight = plotHeight + headerHeight + (lastAnalysisResults.length * rowHeight) + (padding * 3);

                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                await renderAnalysisPlot(lastAnalysisResults, canvas, { x: 0, y: 0, width: canvasWidth, height: plotHeight });

                let currentY = plotHeight + padding;
                const columns = [
                    { header: 'Session Details', x: padding, width: (canvasWidth - padding * 2) * 0.4 },
                    { header: 'Shots', x: padding + (canvasWidth - padding * 2) * 0.4, width: (canvasWidth - padding * 2) * 0.08 },
                    { header: 'MR', x: padding + (canvasWidth - padding * 2) * 0.48, width: (canvasWidth - padding * 2) * 0.12 },
                    { header: 'MR CI (95%)', x: padding + (canvasWidth - padding * 2) * 0.60, width: (canvasWidth - padding * 2) * 0.22 },
                    { header: 'Vel. SD', x: padding + (canvasWidth - padding * 2) * 0.82, width: (canvasWidth - padding * 2) * 0.18 }
                ];

                ctx.font = `bold ${FONT_SIZE_PT * 2.5}px Inter`;
                ctx.fillStyle = '#f9fafb';
                ctx.textBaseline = 'middle';
                columns.forEach(col => {
                    ctx.fillText(col.header, col.x, currentY + headerHeight / 2);
                });
                currentY += headerHeight;
                ctx.strokeStyle = '#4b5563';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(padding, currentY);
                ctx.lineTo(canvasWidth - padding, currentY);
                ctx.stroke();
                
                ctx.font = `${FONT_SIZE_PT * 2.2}px Inter`;
                lastAnalysisResults.forEach((result, index) => {
                    const color = colors[index % colors.length];
                    ctx.fillStyle = color;
                    ctx.fillRect(columns[0].x, currentY + (rowHeight - 40) / 2, 40, 40);

                    const stats = result.stats;
                    const sessionText = result.sessionName.replace(/\s\(\d+ shots\)/, '');

                    ctx.fillStyle = '#f3f4f6';
                    ctx.fillText(sessionText, columns[0].x + 50, currentY + rowHeight / 2);
                    ctx.fillText(stats.n, columns[1].x, currentY + rowHeight / 2);
                    ctx.fillText(`${stats.meanRadius.toFixed(4)} ${stats.units}`, columns[2].x, currentY + rowHeight / 2);
                    ctx.fillText(`[${stats.ci_mean_radius[0].toFixed(4)}, ${stats.ci_mean_radius[1].toFixed(4)}]`, columns[3].x, currentY + rowHeight / 2);
                    ctx.fillText(`${stats.vel_sd !== null ? stats.vel_sd.toFixed(2) : 'N/A'}`, columns[4].x, currentY + rowHeight / 2);
                    currentY += rowHeight;
                });

                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = 'analysis_report.png';
                a.click();
            }

            // Initial population
            sessionSelect.dispatchEvent(new Event('refresh'));
        }

    </script>
</body>
</html>
